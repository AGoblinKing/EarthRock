'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var test = _interopDefault(require('ava'));
var Color = _interopDefault(require('color-js'));
var cuid = _interopDefault(require('cuid'));
require('src/sys/sys.test');

// Stores are observables
class Store  {
	
	

	constructor(value) {
		this.value = value;
	}

	 notify () {
		if (!this.listeners) return
		this.listeners.forEach((listener) => listener(this.value));
	}

	subscribe(listener) {
		return this.listen(listener)
	}

	listen (listener, no_initial = false)  { 
		if (!this.listeners) this.listeners = new Set();

		this.listeners.add(listener);
		
		if (!no_initial) listener(this.get());

		return () => this.listeners.delete(listener)
	}

	get ()  { return this.value }
	
	set (value, silent = false) {
		this.value = value;
		if(silent) return
		
		this.notify();
	}

	update (updator) {
		this.set(updator(this.value));
	}

	toJSON ()  {
		switch (typeof this.value) {
		case `undefined`:
		case `number`:
		case `string`:
			return this.value 

		case `object`:
			if(Set.prototype.isPrototypeOf(this.value)) {
				return Array.from(this.value)
			}

			if (
				Array.isArray(this.value) ||
				this.value === null
			) {
				return this.value
			}
			
			if (this.value.toJSON) {
				return this.value.toJSON()
			}
		}

		return JSON.parse(
			JSON.stringify(this.value)
		)
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);

//# sourceMappingURL=performance-now.js.map
});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

test("store/store", t => {
    const s = new Store(5);
    t.snapshot(s.get());

    s.set(6);
    t.snapshot(s.get());

    s.update((i) => i + 1);
    t.snapshot(s.get());
});

test("store/observable", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.subscribe(($value) => {
            t.snapshot($value);

            raf_1(() => {
                cancel();
                s.set(7);
                resolve();
            });
        });
    });
});

test("store/listen/silent", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.listen(($value) => {
            t.snapshot($value);
            cancel();
            resolve();
        }, true);

        s.set(7);
    });
});

test("store/toJSON", t => {
    t.snapshot(new Store({"foo": "bar"}).toJSON());
    t.snapshot(new Store(5).toJSON());
    t.snapshot(new Store([5, 5]).toJSON());
    t.snapshot(new Store(new Store(5)).toJSON());
});

test("store/set/silent", t => {
    t.plan(1);
    const store = new Store(5);
    store.listen(($value) => {
        t.pass();
    }, true);

    store.set(6, true);
    store.set(7);
});

class Read extends Store {
    constructor(value, setter) {
        super(value);

        if(setter) setter(Store.prototype.set.bind(this));
    }

     p_set(value, silent = false) {
        super.set(value, silent);
    }

    set(value, silent = false) {
        return
    }
}

class Tree extends Read {
	

	constructor(tree, setter) {
		super(tree, setter);
	}

	get_name (name) {
		return super.get()[name]
	}

	reset (target, silent = false) {
		const $tree = {};
		if(target) {
			Object.assign($tree, target);
		}

		this.p_set($tree, silent);
	}

	write (tree_write, silent = false) {
		const $tree = this.get();
		Object.assign($tree, tree_write);

		this.p_set($tree, silent);
	}
}

test("store/tree", t => {
    const tree = new Tree({
        foo: 1,
        bar: "2",
        store: new Store(5),
        stores: new Store(new Store("string"))
    });

    t.snapshot(tree.get());
});

test("store/tree/names", t => {
    const tree = new Tree({
        foo: 1,
        bar: "2",
        store: new Store(5),
        stores: new Store(new Store("string"))
    });

    tree.write({foo: 2});
    t.snapshot(tree.get());
    t.snapshot(tree.get_name("foo"));


    tree.write({
        foo: 5,
        store: 1,
        new_thing: "new"
    });

    t.snapshot(tree.get());
    t.snapshot(tree.toJSON());
});

test("store/read", t => {
    t.plan(3);
    let setter;
    const read = new Read(5, set => {
        setter = set;
    });

    const cancel = read.listen(($value) => {
        t.true($value === 10);
        cancel();
    }, true);

    t.snapshot(read.get());
    read.set(6);
    t.snapshot(read.get());

    setter(10);
});

class Proxy {
    

    get() { return this.value.get() }
    listen(listen) { return this.value.listen(listen) }
    set(value, silent = false) { this.value.set(value, silent); }
    toJSON() { return this.value.toJSON() }
}

class ProxyTree extends Proxy {
    
    
    get_name (name) {
        return this.value.get_name(name)
    }

    reset (target, silent)  {
        return this.value.reset(target, silent)
    }

    write (tree_write, silent) {
        return this.value.write(tree_write, silent)
    }
}

const TILE_COUNT = new Store(1024);

const THEME_BORDER = new Store(``, $value => Color($value)
	.darkenByRatio(0.5)
	.toCSS()
);

const THEME_STYLE = new Read(``, set => {
	let $THEME_BORDER = ``;

	const update = () => set([
		`border: 0.2rem solid ${$THEME_BORDER};`
	].join(``));

	THEME_BORDER.listen($val => {
		$THEME_BORDER = $val;
		update();
	});
});

// whiskers on kittens
const words = [
	`groovy`, `cat`, `bird`, `dog`, `poop`, `cool`, `not`, `okay`, `great`, `terrible`, `wat`,
	`goblin`, `life`, `ferret`, `gregert`, `robert`, `zilla`, `red`, `shirt`, `pants`, `blue`,
	`luna`, `ember`, `embear`, `lunatic`, `boring`, `killa`, `notice`, `thank`, `tank`,
	`under`, `near`, `near`, `quaint`, `potato`, `egg`, `bacon`, `narwhal`, `lamp`, `stairs`, `king`,
	`tyrant`, `grave`, `dire`, `happy`, `amazing`, `terrific`, `terrible`, `good`, `boring`,
	`rip`, `hello`, `world`, `global`, `universal`, `television`, `computer`
];

const tile = (str) => {
	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	return `${Math.abs(hash) % TILE_COUNT.get()}`
};

const random = (count) => Array
	.from(new Array(count))
	.map(() => words[Math.floor(Math.random() * words.length)])
	.join(`_`);

test("lib/text", t => {
    t.snapshot(tile("hello"));
    t.is(typeof random(2), "string");
});

var EWarp; (function (EWarp) {
    const SPACE = "SPACE"; EWarp["SPACE"] = SPACE;
    const MATH = "MATH"; EWarp["MATH"] = MATH;
    const VALUE = "VALUE"; EWarp["VALUE"] = VALUE;
    const MAIL = "MAIL"; EWarp["MAIL"] = MAIL;
})(EWarp || (EWarp = {}));

class Warp extends Proxy {
    
    

    
    

    constructor(data, weave) {
        super();

        this.id = data.id;
        this.type = data.type;
        this.weave = weave;

        // don't init value because who knows what they want
    }

    toJSON() {
        return {
            id: this.id,
            type: this.type,
            value: this.value.toJSON()
        }
    }
}

var ETwist; (function (ETwist) {
    const VISIBLE = "VISIBLE"; ETwist["VISIBLE"] = VISIBLE;
    const PHYSICAL = "PHYSICAL"; ETwist["PHYSICAL"] = PHYSICAL;
    const DATA = "DATA"; ETwist["DATA"] = DATA;
})(ETwist || (ETwist = {}));





class Twist extends ProxyTree {
    
    

    static map_to_stores (twist_data) {
        const stores = {};

        for(let key of Object.keys(twist_data)) {
            stores[key] = new Store(twist_data[key]);
        }

        return stores
    }

    constructor (weave, twist_data) {
        super();

        this.weave = weave;
        this.value = new Tree(Twist.map_to_stores(twist_data));
    }
}

class Visible extends Twist {
    static __initStatic() {this.count = 100;} 
    static __initStatic2() {this.data = Visible.create_data(100);}

    static __initStatic3() {this.defaults = { 
        position: [0, 0, 0],
        sprite: [0],
        scale: [1],
        color: [255, 255, 255, 1],
        rotation: [0]
    };}

    static create_data(size) { 
        return {
            position: new Float32Array(size * 3),
            sprite: new Float32Array(size),
            scale: new Float32Array(size),
            color : new Float32Array(size * 4)
        }
    }

    constructor(weave, visible_data) {
        super(weave, visible_data);
    }
} Visible.__initStatic(); Visible.__initStatic2(); Visible.__initStatic3();

class Data extends Twist  {
    constructor(weave,  data) {
        super(weave, data);
    }
}

class Physical extends Twist {
    constructor(weave,  visible_data) {
        super(weave, visible_data);
    }
}

class Space extends Warp {
    

    static create (type, weave, twist_data) {
        switch(type) {
            case ETwist.DATA:
                return new Data(weave, twist_data)
            case ETwist.VISIBLE: 
                return new Visible(weave, twist_data )
            case ETwist.PHYSICAL:
                return new Physical(weave, twist_data )
        }

        throw new Error(`unknown twist ${type}`)
    }


    constructor(warp_data, weave) {
        super(warp_data, weave);

        const data = warp_data.value;

        const twists = {};
        for(let type of Object.keys(data)) {
            twists[type] = Space.create(type, weave, data[type]);
        }

        this.value = new Tree(twists);
    }

    get_name (name) {
        return this.value.get_name(name)
    }

    reset (target, silent)  {
        return this.value.reset(target, silent)
    }

    write (tree_write, silent) {
        return this.value.write(tree_write, silent)
    }
}

class Weave {
    
    
    
    

    // caches
    
    

    // clean up
    

    create_warp($warp) {
        switch($warp.type) {
            case undefined:
                $warp.type = EWarp.SPACE;
            case EWarp.SPACE:
                return new Space($warp, this)
            case EWarp.MAIL:
            case EWarp.VALUE:
            case EWarp.MATH:
        }

        throw new Error(`warp/unknown ${$warp}`)
    }

    constructor(data) {
        this.name = new Store(data.name);
        this.wefts = new Tree(data.wefts);
        this.warps = new Tree({});
        this.rezed = new Store(new Set(data.rezed));

        this.cancels = new Set();

        this.wefts_reverse = new Tree({}, set => {
            this.cancels.add(this.wefts.listen(($wefts) => {
                const w_r = {};
                for(let key of Object.keys($wefts)) {
                    w_r[$wefts[key]] = key;   
                }

                set(w_r);
            }));
        });

        this.write(data.warps);
    }

    write(warp_data, silent = false)  {
        const warps = {};

        for(let id of Object.keys(warp_data)) {
            const warp = warp_data[id];  
            warp.id = warp.id === "cuid" ? cuid() : id;

            warps[id] = this.create_warp(warp);
        }

        this.warps.set(Object.assign(this.warps.get(), warps), silent);
        return warps
    }

    delete(...ids) {
        const $warps = this.warps.get();
        const $wefts = this.wefts.get();
        const $wefts_r = this.wefts_reverse.get();
        const $rezed = this.rezed.get();

        for(let id of ids) {
            delete $warps[id];
            delete $wefts[id];
            $rezed.delete(id);

            const r = $wefts_r[id];
            if(r) {
                delete $wefts[r];
            }
        }
        // TODO: Notify destruction if rezed

        this.warps.set($warps);
        this.wefts.set($wefts);
        this.rezed.set($rezed);
    }

    destroy() {
        this.delete(...Object.keys(this.warps.get()));
        for(let cancel of Array.from(this.cancels)) {
            cancel();
        }
        this.cancels.clear();
    }

    toJSON()  {
        return {
            name: this.name.get(),
            wefts: this.wefts.get(),
            warps: this.warps.toJSON(),
            rezed: this.rezed.toJSON()
        }
    }
}

test("weave/", t => {
    const data = {
        name: "test",
        warps: {
            foo: { type: EWarp.SPACE, value: {} },
            test: { type: EWarp.SPACE, value: {} }
        },
        wefts: {
            foo: "test"
        },
        rezed: [
            "foo"
        ]
    };

    const weave = new Weave(data);

    t.deepEqual(data, weave.toJSON());

    weave.delete("foo", "test");
    
    t.snapshot(weave.toJSON());

    weave.write({
        foo: { value: {}},
        bar: { type: EWarp.SPACE, value: {}}
    });

    t.snapshot(weave.toJSON());

    weave.write({
        foo: { value: {} }
    });
    
    t.snapshot(weave.toJSON());

    weave.destroy();
    t.snapshot(weave.toJSON());
});

test("warp/", t => {
    const weave = new Weave({
        name: "test",
        warps: {
            hello: {
                value: {VISIBLE: {
                    sprite: [5]
                }}
            }
        },
        wefts: {},
        rezed: []
    } );

    const { hello } = weave.warps.get();
    t.snapshot(hello.toJSON());
    weave.destroy();
});

test("warp/space", t => {
    const weave = new Weave({
        name: "test",
        warps: {
            hello: {
                value: {VISIBLE: {
                    sprite: [5]
                }}
            }
        },
        wefts: {},
        rezed: []
    } );

    const hello = weave.warps.get().hello; 

    hello.write({ DATA: { foo: 5 } });
    t.snapshot(hello.toJSON());

    const vis = hello.get_name("VISIBLE");
    t.snapshot(vis.toJSON());
    vis.write({
        foo: new Store(5) 
    });

    t.snapshot(vis.get());
});

test("twist/visible", t => {
    const weave = new Weave({
        name: "test",
        wefts: {},
        rezed: [],
        warps: {
            test: {
                value: {
                    VISIBLE: {
                        sprite: [2]
                    }
                }
            }
        }
    });

    t.snapshot(weave.toJSON());
});

test("twist/data", t => {
    const weave = new Weave({
        name: "test",
        wefts: {},
        rezed: [],
        warps: {
            test: {
                value: {
                    DATA: {
                        arbitrary: "hello"
                    }
                }
            }
        }
    });

    t.snapshot(weave.toJSON());
});

test("twist/physical", t => {
    const weave = new Weave({
        name: "test",
        wefts: {},
        rezed: [],
        warps: {
            test: {
                value: {
                    PHYSICAL: {
                        position: [0,0,0]
                    }
                }
            }
        }
    });

    t.snapshot(weave.toJSON());
});
//# sourceMappingURL=bundle.test.js.map

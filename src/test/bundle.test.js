'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var test = _interopDefault(require('ava'));

// Stores are observables
class Store  {
	
	

	constructor(value) {
		this.value = value;
	}

	notify () {
		if (!this.listeners) return
		this.listeners.forEach((listener) => listener(this.value));
	}

	subscribe (listener) {
		return this.listen(listener)
	}

	listen (listener, no_initial = false)  { 
		if (!this.listeners) this.listeners = new Set();

		this.listeners.add(listener);
		
		if (!no_initial) listener(this.get());

		return () => this.listeners.delete(listener)
	}

	get ()  { return this.value }
	
	set (value, silent = false) {
		this.value = value;
		if(silent) return
		
		this.notify();
	}

	update (updator) {
		this.set(updator(this.value));
	}

	toJSON ()  {
		switch (typeof this.value) {
		case `undefined`:
		case `number`:
		case `string`:
			return this.value 

		case `object`:
			if(Set.prototype.isPrototypeOf(this.value)) {
				return Array.from(this.value)
			}

			if (
				Array.isArray(this.value) ||
				this.value === null
			) {
				return this.value
			}
			
			if (this.value.toJSON) {
				return this.value.toJSON()
			}
		}

		return JSON.parse(
			JSON.stringify(this.value)
		)
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);


});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

test("store/store", t => {
    const s = new Store(5);
    t.snapshot(s.get());

    s.set(6);
    t.snapshot(s.get());

    s.update((i) => i + 1);
    t.snapshot(s.get());
});

test("store/observable", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.subscribe(($value) => {
            t.snapshot($value);

            raf_1(() => {
                cancel();
                s.set(7);
                resolve();
            });
        });
    });
});

test("store/listen/silent", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.listen(($value) => {
            t.snapshot($value);
            cancel();
            resolve();
        }, true);

        s.set(7);
    });
});

test("store/toJSON", t => {
    t.snapshot(new Store({"foo": "bar"}).toJSON());
    t.snapshot(new Store(5).toJSON());
    t.snapshot(new Store([5, 5]).toJSON());
    t.snapshot(new Store(new Store(5)).toJSON());
});

test("store/set/silent", t => {
    t.plan(1);
    const store = new Store(5);
    store.listen(($value) => {
        t.pass();
    }, true);

    store.set(6, true);
    store.set(7);
});

class Read extends Store {
    constructor(value, setter) {
        super(value);

        if(setter) setter(Store.prototype.set.bind(this));
    }

     p_set(value, silent = false) {
        super.set(value, silent);
    }

    set(value, silent = false) {
        return
    }
}

const void_fn = () => {};

var EGrok; (function (EGrok) {
	const ADD = 0; EGrok[EGrok["ADD"] = ADD] = "ADD";
	const REMOVE = ADD + 1; EGrok[EGrok["REMOVE"] = REMOVE] = "REMOVE";
	const UPDATE = REMOVE + 1; EGrok[EGrok["UPDATE"] = UPDATE] = "UPDATE";
	// living
	const START = UPDATE + 1; EGrok[EGrok["START"] = START] = "START";
	const STOP = START + 1; EGrok[EGrok["STOP"] = STOP] = "STOP";
	// weave
	const THREAD = STOP + 1; EGrok[EGrok["THREAD"] = THREAD] = "THREAD";
	const UNTHREAD = THREAD + 1; EGrok[EGrok["UNTHREAD"] = UNTHREAD] = "UNTHREAD";
})(EGrok || (EGrok = {}));



















class Tree extends Read {
	
	
	

	constructor(tree = {}, setter) {
		super({}, setter);

		this.add(tree);
	}

	groke(action, path, value) {
		if (!this.grokers) return

		for (let grok of Array.from(this.grokers)) {
			grok(action, path, value);
		}

		switch (action) {
			case EGrok.ADD:
				const val = this.query(...path.split('/'));
				this.groke_cancels[path] = val.grok
					? val.grok((s_action, s_path, s_value) => {
							for (let grok of Array.from(this.grokers)) {
								grok(s_action, `${path}/${s_path}`, s_value);
							}
					  })
					: val.listen
					? val.listen($val => {
							this.groke(EGrok.UPDATE, path, $val);
					  })
					: this.groke(EGrok.UPDATE, path, val);

				break
			case EGrok.REMOVE:
				this.groke_cancels[path]();
				delete this.groke_cancels[path];
				break
		}

		return void_fn
	}

	has(name) {
		return this.query(name) !== undefined
	}

	add(tree_json, silent = false) {
		const $tree = this.get();

		for (let [key, value] of Object.entries(tree_json)) {
			const is_store = value && value.get !== undefined;
			const is_obj =
				(Array.isArray(value) ||
					['string', 'number', 'boolean'].indexOf(typeof value) !==
						-1) === false;

			const new_val = ($tree[key] = is_store
				? value
				: is_obj
				? new Tree()
				: new Store(value));

			this.groke(EGrok.ADD, key, {
				value: new_val.toJSON()
			});
		}

		this.p_set($tree, silent);

		return tree_json
	}

	remove(name, silent = false) {
		delete this.value[name];
		if (!silent) this.notify();

		this.groke(EGrok.REMOVE, name);
	}

	query(...steps) {
		const cursor = this.value[steps.shift()]; 

		if (steps.length === 0 || !cursor) return cursor
		return cursor.query(...steps)
	}

	count() {
		return Object.keys(this.get()).length
	}

	groker(action, path, value) {
		const split = path.split('/');
		const item =
			split.length === 1 ? this : this.query(...split.slice(0, -1));

		const key = split[split.length - 1];

		switch (action) {
			case EGrok.ADD:
				item.add({
					[key]: value
				});
				break
			case EGrok.REMOVE:
				item.remove(key);
				break
			case EGrok.UPDATE:
				if (split.length === 1) {
					item.set(value);
				} else {
					item.query(key).set(value);
				}
		}
	}

	grok(groker) {
		if (this.grokers === undefined) {
			this.grokers = new Set([groker]);
			this.groke_cancels = {};

			for (let [key, value] of Object.entries(this.get())) {
				const $v = value; 
				this.groke(EGrok.ADD, key, $v.toJSON ? $v.toJSON() : value);
			}
		} else {
			this.grokers.add(groker);
			for (let [key, value] of Object.entries(this.get())) {
				const $v = value; 
				groker(EGrok.ADD, key, value);
			}
		}

		return () => {
			this.grokers.delete(groker);
			if (this.grokers.size !== 0) return

			delete this.grokers;
			for (let cancel of Object.values(this.groke_cancels)) {
				cancel();
			}

			delete this.groke_cancels;
		}
	}
}

test('store/tree', t => {
	const tree = new Tree({
		foo: 1,
		bar: '2',
		store: new Store(5),
		stores: new Store(new Store('string'))
	});

	t.snapshot(tree.get());

	t.snapshot(tree.count());
});

test('store/tree/names', t => {
	const tree = new Tree({
		foo: 1,
		bar: '2',
		store: new Store(5),
		stores: new Store(new Store('string'))
	});

	tree.add({ foo: 2 });
	t.snapshot(tree.get());
	t.snapshot(tree.query('foo'));

	tree.add({
		foo: 5,
		store: 1,
		new_thing: 'new'
	});

	t.snapshot(tree.get());
	t.snapshot(tree.toJSON());

	tree.remove('store');

	t.snapshot(tree.get());
});

test('store/tree/query', t => {
	const tree = new Tree({
		foo: 1,
		nest: new Tree({
			deeper: new Tree({
				final: 3
			}),
			mid: 2
		})
	});

	t.snapshot(tree.query('foo'));
	t.snapshot(tree.query('nest'));
	t.snapshot(tree.query('nest', 'mid'));
	t.snapshot(tree.query('nest', 'deeper'));
	t.snapshot(tree.query('nest', 'deeper', 'final'));
});

test('store/tree/grok', t => {
	const tree = new Tree({
		trend: 1,
		den: new Store('fen'),
		hello: new Tree({
			men: 2,
			there: new Tree({
				friend: new Store(0),
				tem: 1
			})
		})
	});

	const tree_2 = new Tree({});

	const cancel_2 = tree.grok(tree_2.groker.bind(tree_2));

	t.snapshot(tree.toJSON(), 'tree 1');

	const cancel = tree.grok((action, key, value) => {
		t.snapshot({ action, key, value }, 'groks');
	});

	tree.remove('trend');

	t.snapshot(tree_2.toJSON(), 'tree2 no hello');
	t.snapshot(tree.toJSON(), 'tree 1 no hello');
	cancel();

	t.snapshot(tree_2.toJSON(), 'tree 2');

	t.deepEqual(tree.toJSON(), tree_2.toJSON());

	tree.query('hello', 'there').add({
		again: new Store(5)
	});

	tree.query('hello', 'there', 'again').set(10);

	t.snapshot(tree_2.toJSON(), 'tree 2 with again');
	t.deepEqual(tree.toJSON(), tree_2.toJSON());

	cancel_2();
});

test("store/read", t => {
    t.plan(3);
    let setter;
    const read = new Read(5, set => {
        setter = set;
    });

    const cancel = read.listen(($value) => {
        t.true($value === 10);
        cancel();
    }, true);

    t.snapshot(read.get());
    read.set(6);
    t.snapshot(read.get());

    setter(10);
});

class Proxy {
	

	get() {
		return this.value.get()
	}
	listen(listen) {
		return this.value.listen(listen)
	}
	set(value, silent = false) {
		this.value.set(value, silent);
	}
	toJSON() {
		return this.value.toJSON()
	}
	notify() {
		this.value.notify();
	}

	subscribe(listen) {
		return this.listen(listen)
	}
}

class ProxyTree extends Proxy
 {
	

	add(tree_write, silent) {
		return this.value.add(tree_write, silent)
	}

	remove(name, silent) {
		this.value.remove(name, silent);
	}

	query(...steps) {
		return this.value.query(...steps)
	}

	has(name) {
		return this.query(name) !== undefined
	}

	grok(groker) {
		return this.value.grok(groker)
	}

	groker(action, key, value) {
		return this.value.groker(action, key, value)
	}

	groke(action, key, value) {
		return this.value.groke(action, key, value)
	}
}

class BufferValue extends Store {
    set (value, silent = false) {
        this.get().set(value);
        if(silent === false) this.notify();
    }
}

class Buffer extends Tree {
    
    
    
    

     create_data (size) {
        const data = {};
        
        for(let key of Object.keys(this.defaults)) {
            data[key] = new Float32Array(this.defaults[key].length * size);

            // copy existing data
            if(this.value && Object.keys(this.value).length > 0) {
                data[key].set(this.value[key]);
            }
        }
        
        if(this.available) {
            const additions = Array.from(Array(size - this.count).keys()).map(i => i + this.count);
            this.available = new Set([...Array.from(this.available), ...additions]);
        } else {
            this.available = new Set(Array(size).keys());
        }

        this.value = data;
        this.count = size;
    }

    constructor (defaults, initial_size = 100) {
        super();

        this.defaults = defaults;
        this.create_data(initial_size);
    }
    
    allocates (...data)  {
        const results = [];
        for(let datum of data) {
            results.push(this.allocate(datum));
        }

        return results
    }

    allocate (datum)  {
        const buffer_view = {};
        let cursor = this.available.values().next().value;
        if(cursor === undefined) {
            this.resize();
            cursor = this.available.values().next().value;
        }

        this.available.delete(cursor);

        for(let key of Object.keys(this.defaults)) {
            const len = this.defaults[key].length;
            const idx = cursor * len; 
            const view = this.value[key].subarray(idx, idx + len);

            view.set(datum[key] ? datum[key] : this.defaults[key]);

            buffer_view[key] = new BufferValue(view);
        }

        return [buffer_view, cursor]
    }

    free (idx) {
        this.available.add(idx);

        for(let key of Object.keys(this.defaults)) {    
            const len = this.defaults[key].length;
            this.value[key].set(Array(len).fill(0), len * idx);
        }
    }

    resize (size) {
        if(size === undefined) size = this.count * 2;
        if(size < this.count) throw new Error("cannot reduce the size of a buffer")

        this.create_data(size);
        this.notify();
    }

    hydrate (data) {
        for(let key of Object.keys(this.value)) {
            this.value[key].set(data[key]);
        }

        this.notify();
    }

    toJSON ()  {
        const json = {};
        for(let key of Object.keys(this.value)) {
            json[key] = this.value[key];
        }

        return json
    }
}

var ELivingAction; (function (ELivingAction) {
	const CREATE = 'create'; ELivingAction["CREATE"] = CREATE;
	const REZ = 'rez'; ELivingAction["REZ"] = REZ;
	const DEREZ = 'derez'; ELivingAction["DEREZ"] = DEREZ;
	const DESTROY = 'destroy'; ELivingAction["DESTROY"] = DESTROY;
})(ELivingAction || (ELivingAction = {}));

var ELivingStatus; (function (ELivingStatus) {
	const VOID = 'VOID'; ELivingStatus["VOID"] = VOID;
	const CREATED = 'CREATED'; ELivingStatus["CREATED"] = CREATED;
	const REZED = 'REZED'; ELivingStatus["REZED"] = REZED;
})(ELivingStatus || (ELivingStatus = {}));

class Living extends ProxyTree {constructor(...args) { super(...args); Living.prototype.__init.call(this); }
	
	 __init() {this.status = new Store(ELivingStatus.VOID);}

	add(living_data, silent = false) {
		// when adding check to see if they have rezed/value
		// if they do its a living
		super.add(living_data, silent);
		const $status = this.status.get();
		const items = Object.entries(living_data);

		switch ($status) {
			case ELivingStatus.CREATED:
				for (let [_, item] of items) {
					item.create && item.create();
				}

			case ELivingStatus.REZED:
				const $rezed = this.rezed && this.rezed.get();

				// create doesn't auto rez
				// so you can batch creates together then rez
				for (let [name, item] of items) {
					if ($rezed && !$rezed[name]) continue
					item.rez && item.rez();
				}
		}
	}

	remove(name, silent = false) {
		const $value = this.get(); 

		if ($value[name] && $value[name].destroy) {
			$value[name].destroy();
		}

		const $rezed = this.rezed && this.rezed.get();
		if ($rezed) {
			$rezed.delete(name);
		}

		super.remove(name, silent);
	}

	removes(...names) {
		for (let name of names) {
			this.remove(name, true);
		}

		this.notify();
	}

	create() {
		if (this.status.get() !== ELivingStatus.VOID) {
			throw new Error('Tried to create a nonvoid living class')
		}

		// run through my tree to guarantee its destroyed
		let sub;
		for (sub of Object.values(this.get())) {
			sub.create && sub.create();
		}

		this.status.set(ELivingStatus.CREATED);
	}

	destroy() {
		if (this.status.get() === ELivingStatus.REZED) {
			this.derez();
		}

		let sub;
		for (sub of Object.values(this.get())) {
			sub.destroy && sub.destroy();
		}

		this.status.set(ELivingStatus.VOID);
	}

	rez() {
		if (this.status.get() === ELivingStatus.VOID) {
			this.create();
		}

		const rezed = this.rezed && this.rezed.get();

		for (let [name, sub] of Object.entries(this.get())) {
			if (rezed && !rezed.has(name)) continue
			;(sub ).rez && (sub ).rez();
		}

		this.status.set(ELivingStatus.REZED);
	}

	derez() {
		if (this.status.get() !== ELivingStatus.REZED) {
			return
		}

		const $rezed = this.rezed && this.rezed.get();

		for (let [name, sub] of Object.entries(this.get())) {
			if ($rezed && !$rezed.has(name)) continue
			;(sub ).derez && (sub ).derez();
		}

		this.status.set(ELivingStatus.CREATED);
	}

	start_all(...all) {
		all = all.length === 0 ? Object.keys(this.get()) : all;
		for (let name of all) {
			this.start(name);
		}
	}

	start(...names) {
		const $rezed = this.rezed && this.rezed.get();

		for (let name of names) {
			const item = this.query(name);

			if (!item) continue

			// can only rez if I am
			if (this.status.get() === ELivingStatus.REZED) {
				; (item ).rez && (item ).rez();
			}

			if ($rezed) {
				$rezed.add(name);
				this.rezed.notify();
			}

			this.groke(EGrok.START, name);
		}
	}

	stop(...names) {
		const $rezed = this.rezed && this.rezed.get();
		for (let name of names) {
			const item = this.query(name);
			if (!item) continue // can derez whenever though

			;(item ).derez && (item ).derez();

			if (!$rezed) continue

			$rezed.delete(name);
			this.groke(EGrok.STOP, name);
		}

		this.rezed.notify();
	}

	restart(name) {
		this.stop(name);
		this.start(name);
	}

	toJSON() {
		return {
			value: this.value.toJSON(),
			rezed: this.rezed ? this.rezed.toJSON() : undefined
		}
	}

	ensure(first, ...path) {
		let $item = this.query(first);

		if ($item === undefined) {
			this.add({
				[first]: {}
			});

			$item = this.query(first);
		}

		if (path.length === 0) return $item

		if ($item instanceof Living) {
			return $item.ensure(path[0], ...path.slice(1))
		}

		throw new Error('tried to ensure non living item')
	}
	
	groker(action, path, value) {
		const parts = path.split("/");
		const target = parts.length === 1 
			? this
			: this.query(...parts.slice(0, -1));
		
		const key = path[path.length - 1];

		// path can be tiered, split it out and start based on parent
		switch (action) {
			case EGrok.START:
				target.start && target.start(key);
				break
			case EGrok.STOP:
				target.stop && target.stop(key);
				break
			case EGrok.ADD:
				// could be adding a living to a living
				if (
					value.value !== undefined &&
					value.get === undefined 
				) {
					super.groker(action, key, new Living);	
				}
				break
			default:
				super.groker(action, key, value);
		}
	}
	
	grok(groker) {
		const cancel = super.grok(groker);
		if (this.rezed !== undefined) {
			for (let key of Array.from(this.rezed.get())) {
				groker(EGrok.START, key);
			}
		}
		return cancel
	}
}

class Transformer extends Store {
    

    constructor(initial, transformer) {
        super(transformer(initial));
        this.transformer = transformer;
    }
    
    set (value) {
        super.set(this.transformer(value));
    }
}

test("store/buffer", t => {
    const buffer = new Buffer({
        test: [1, 2],
        2: [3, 4]
    }, 3);

    t.snapshot(buffer.toJSON());

    const [item, idx] = buffer.allocate({test: [0, 1]});
    
    t.snapshot(buffer.toJSON());
    t.snapshot(item.test.get());

    const test = item.test.get();
    test[0] = 5;
    item.test.notify();

    t.snapshot(buffer.toJSON());

    buffer.free(0);
    t.snapshot(buffer.toJSON());

    const [view, cursor] = buffer.allocate({test: [1, 2]});
    t.snapshot(view, "allocates a view");

    view.test.set([5, 6]);
    t.snapshot(view, "is setable");

    buffer.allocates({test: [3, 4]}, {test: [5, 6]}, {test: [7, 9]});

    t.snapshot(buffer.toJSON(), "allocates works, and resizes");

    buffer.resize();
    t.snapshot(buffer.toJSON(), "resizeable");

    buffer.hydrate({
        test: [50, 60],
        2: [50, 60]
    });

    t.snapshot(buffer.toJSON(), "hydratable");
});

class Test extends Living {
	constructor(count) {
		super();

		const $value = {};
		for (let i = 0; i < count; i++) {
			$value[`${i}`] = new Test(0);
		}

		this.value = new Tree($value);
		this.rezed = new Store(new Set(['1']));
	}

	add(adds, silent = false) {
		const new_add = {};
		for (let [key, value] of Object.entries(adds)) {
			const test = new Test(0);
		}
		return super.add(new_add, false)
	}
}

test('store/living', t => {
	const tester = new Test(5);

	t.snapshot(tester);

	tester.create();

	t.snapshot(tester);

	tester.add({
		6: {
			value: 1
		}
	});

	t.snapshot(tester.toJSON());

	tester.remove('2');
	t.snapshot(tester);

	tester.start('6');

	t.snapshot(tester);

	tester.query('6').start('0');
	tester.rez();

	t.snapshot(tester);

	tester.derez();
	t.snapshot(tester);

	tester.start('0');
	tester.stop('6');

	tester.rez();

	t.snapshot(tester);

	tester.remove('0');
	t.snapshot(tester);

	tester.destroy();

	t.snapshot(tester);

	tester.create();
	tester.rez();

	t.snapshot(tester);

	t.snapshot(tester.query('6', '0'));
});

test('store/living/grok', t => {
	const tester = new Test(6);
	const test_remote = new Test(1);

	t.snapshot(tester.toJSON());

	const cancel = tester.grok((action, key, value) => {
		t.snapshot({ action, key, value }, 'grok');
		test_remote.groker(action, key, value);
	});

	t.snapshot(tester.toJSON(), 'local');
	t.snapshot(test_remote.toJSON(), 'remote');

	t.deepEqual(test_remote.toJSON(), tester.toJSON());
	cancel();
});

class TestProxy extends Proxy {constructor(...args) { super(...args); TestProxy.prototype.__init.call(this); }
    __init() {this.value = new Store(5);}
}

class TestProxyTree extends ProxyTree {constructor(...args2) { super(...args2); TestProxyTree.prototype.__init2.call(this); }
    __init2() {this.value = new Tree({
        test: 5,
        foo: 6
    });}
}

test("store/proxy", t => {
    const proxy = new TestProxy();

    t.snapshot(proxy.get());
    
    proxy.set(6);

    t.snapshot(proxy.toJSON());
});

test("store/proxy/tree", t => {
    const proxy = new TestProxyTree();

    t.snapshot(proxy.get());

    proxy.add({
        foos: 7
    });

    t.snapshot(proxy.toJSON());

    proxy.remove("foo");

    t.snapshot(proxy.get());
});

test("store/transformer", t => {
    const store = new Transformer(1, (i) => i + 1);

    t.snapshot(store.get());
    store.set(5);

    t.snapshot(store.get());
});

const TILE_COUNT = 1024;

const str_color = (str) => {
	if (!str) return `#111`

	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	let color = `#`;
	for (let i = 0; i < 3; i++) {
		const value = (hash >> (i * 8)) & 0xff;
		color += (`00` + value.toString(16)).substr(-2);
	}

	return color
};

const color = str_color;

// whiskers on kittens
const words = [
	`groovy`,
	`cat`,
	`bird`,
	`dog`,
	`cool`,
	`okay`,
	`great`,
	`wat`,
	`goblin`,
	`life`,
	`ferret`,
	`gregert`,
	`robert`,
	`zilla`,
	`red`,
	`shirt`,
	`pants`,
	`blue`,
	`luna`,
	`ember`,
	`embear`,
	`notice`,
	`thank`,
	`happy`,
	`pungent`,
	`rich`,
	`bank`,
	`under`,
	`over`,
	`near`,
	`quaint`,
	`potato`,
	`egg`,
	`bacon`,
	`narwhal`,
	`lamp`,
	`stairs`,
	`king`,
	`amazing`,
	`terrific`,
	`good`,
	`exciting`,
	`hello`,
	`world`,
	`global`,
	`universal`,
	`television`,
	`computer`,
	`phone`,
	`bus`,
	`car`,
	`mouse`
];

const tile = (str) => {
	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	return `${Math.abs(hash) % TILE_COUNT}`
};

const random = (count) =>
	Array.from(new Array(count))
		.map(() => words[Math.floor(Math.random() * words.length)])
		.join(`_`);

test("lib/text", t => {
    t.snapshot(tile("hello"));
    t.is(typeof random(2), "string");
});

const is_character = /[a-zA-Z]/;

const json = (value) => {
	if (typeof value !== `string`) return value

	if (value.indexOf(`.`) === -1 && value.indexOf(`,`) === -1) {
		const n = parseInt(value);
		if (typeof n === `number` && !isNaN(n)) {
			return n
		}
	}

	// is character
	if(value[0] !== undefined && is_character.test(value[0])) return value

	try {
		return JSON.parse(value) 
	} catch (ex) {
		return value
	}
};

test("lib/parse", t => {
    t.snapshot(json("5"));
    t.snapshot(json("5.9"));
    t.snapshot(json("hello"));
    t.snapshot(json("[5]"));
    t.snapshot(json("{\"5\": 5}"));
});

var EWarp; (function (EWarp) {
    const SPACE = "SPACE"; EWarp["SPACE"] = SPACE;
    const MATH = "MATH"; EWarp["MATH"] = MATH;
    const VALUE = "VALUE"; EWarp["VALUE"] = VALUE;
    const MAIL = "MAIL"; EWarp["MAIL"] = MAIL;
})(EWarp || (EWarp = {}));

class Warp extends Living {
    
    

    

    constructor (data, weave) {
        super();

        this.name = data.name;
        this.type = data.type;
        this.weave = weave;
        
        // don't init value because who knows what they want
    }

    toJSON () {
        return {
            name: this.name,
            type: this.type,
            value: this.value.toJSON()
        }
    }
}

var ETwist; (function (ETwist) {
    const VISIBLE = "VISIBLE"; ETwist["VISIBLE"] = VISIBLE;
    const PHYSICAL = "PHYSICAL"; ETwist["PHYSICAL"] = PHYSICAL;
    const DATA = "DATA"; ETwist["DATA"] = DATA;
})(ETwist || (ETwist = {}));





class Twist extends Living {
    
    
    
    
    constructor (weave, space) {
        super();

        this.space = space;
        this.weave = weave;
        this.value = new Tree({});
    }

    add (data, silent = false) {
        const write = {};
        for(let [name, value] of Object.entries(data)) {
            if(value instanceof Store) {
                write[name] = value;
            } else {
                write[name] = new Store(value);
            }
        }

        super.add(write, silent);
    }

    toJSON () {
        return this.value.toJSON()
    }
}

// Visible spaces
class Visible extends Twist { 
    static __initStatic() {this.defaults = { 
        position: [0, 0, 0],
        sprite: [0],
        scale: [1],
        color: [255, 255, 255, 1],
        rotation: [0]
    };}

    static __initStatic2() {this.data = new Buffer(Visible.defaults);}

    

    constructor(weave, space, visible_data) {
        // set the views
        super(weave, space);
        const [view, idx] = Visible.data.allocate(visible_data);
        this.index = idx;
        this.add(view);
    }

    toJSON() {
        const json = {};
        const $value = this.get();
        for(let key of Object.keys($value)) {
            const $item = $value[key].get();

            json[key] = Array.from($item);
        }

        return json
    }
} Visible.__initStatic(); Visible.__initStatic2();

class Data extends Twist  {
    constructor(weave,  space, data) {
        super(weave, space);
        this.add(data);
    }
}

class Physical extends Twist {
    constructor(weave, space, physical_data = {}) {
        super(weave, space);
        this.add(physical_data);
    }
}

class Space extends Warp {
     __init() {this.value = new Tree();}

    constructor (warp_data, weave) {
        super(warp_data, weave);Space.prototype.__init.call(this);

        this.add(warp_data.value || {});
    }

    add (data) {
        const adds = {};

        for(let type of Object.keys(data)) {
            adds[type] = this.create_twist(type, data[type]);
        }

        super.add(adds);
    }

     create_twist (type, twist_data = {}) {
        switch(type) {
            case ETwist.DATA:
                return new Data(this.weave, this, twist_data)
            case ETwist.VISIBLE: 
                return new Visible(this.weave, this, twist_data )
            case ETwist.PHYSICAL:
                return new Physical(this.weave, this, twist_data )
        }

        return new Store(twist_data)
    }   

    create () {
        super.create();
        this.weave.spaces.add({ [this.name]: this });
    }

    destroy () {
        super.destroy();
        this.weave.spaces.remove(this.name);
    }
}

// export * from "./mail"
// export * from "./value"

class Weave extends Living {
	
	
	 __init() {this.value = new Tree({});}

	// caches
	
	 __init2() {this.spaces = new Tree({});}

	// clean up
	  __init3() {this.cancels = new Set();}
	
	 __init4() {this.nerves = {};}

	create_warp($warp) {
		switch ($warp.type) {
			case undefined:
				$warp.type = EWarp.SPACE;
			case EWarp.SPACE:
				return new Space($warp, this)
			case EWarp.MAIL:
			case EWarp.VALUE:
			case EWarp.MATH:
		}

		throw new Error(`warp/unknown ${$warp}`)
	}

	constructor(data) {
		super();Weave.prototype.__init.call(this);Weave.prototype.__init2.call(this);Weave.prototype.__init3.call(this);Weave.prototype.__init4.call(this);

		if (data.name === undefined) {
			throw new Error('Undefined name for weave')
		}

		this.name = data.name;
		this.threads = new Tree(data.thread || {});
		this.rezed = new Store(new Set(data.rezed || []));

		this.threads_reverse = new Tree({}, set => {
			this.cancels.add(
				this.threads.listen($threads => {
					const w_r = {};
					for (let key of Object.keys($threads)) {
						w_r[$threads[key]] = key;
					}

					set(w_r);
				})
			);
		});

		this.add(data.value || {});
	}

	add(warp_data, silent = false) {
		if (!warp_data) return
		const warps = {};

		for (let [name, warp] of Object.entries(warp_data)) {
			if (warp instanceof Warp) {
				warps[name] = warp;
				continue
			}

			warp.name = name;
			warps[name] = this.create_warp(warp);
		}

		super.add(warps, silent);

		return warps
	}

	rez() {
		super.rez();

		// connect threads to form nerves
		this.thread_cancel = this.threads.listen(this.thread_update.bind(this));
	}

	thread_update($threads) {
		for (let [name, cancel] of Object.entries(this.nerves)) {
			if ($threads[name]) {
				delete $threads[name];
				continue
			}

			cancel();
			delete this.nerves[name];
		}

		for (let [from, to] of Object.entries($threads)) {
			const f = this.query(...from.split('/'));
			const t = this.query(...to.split('/'));
			if (!f || !t) continue
			this.nerves[from] = f.listen(t.set.bind(t));
		}
	}

	derez() {
		super.derez();

		for (let cancel of Object.values(this.nerves)) {
			cancel();
		}

		this.thread_cancel();
	}

	removes(...names) {
		const $warps = this.value.get();
		const $wefts = this.threads.get();
		const $wefts_r = this.threads_reverse.get();
		const $rezed = this.rezed.get();

		for (let name of names) {
			const warp = $warps[name];
			if (warp) warp.destroy();

			delete $warps[name];
			delete $wefts[name];
			$rezed.delete(name);

			const r = $wefts_r[name];
			if (r) {
				delete $wefts[r];
			}
		}

		this.value.set($warps);
		this.threads.set($wefts);
		this.rezed.set($rezed);
	}

	remove(name) {
		this.removes(name);
	}

	destroy() {
		super.destroy();

		for (let cancel of Array.from(this.cancels)) {
			cancel();
		}

		this.cancels.clear();
	}

	toJSON() {
		return {
			name: this.name,
			thread: this.threads.get(),

			value: this.value.toJSON(),
			rezed: this.rezed.toJSON()
		}
	}

	// TODO: custom grok/groker that provides thread updates
}

test("weave/", t => {
    const data = {
        name: "test",
        value: {
            foo: { type: EWarp.SPACE, value: {} },
            test: { type: EWarp.SPACE, value: {} }
        },
        thread: {
            foo: "test"
        },
        rezed: [
            "foo"
        ]
    };

    const weave = new Weave(data);

    t.deepEqual(data, weave.toJSON());

    weave.removes("foo", "test");
    
    t.snapshot(weave.toJSON());

    weave.add({
        foo: { value: {}},
        bar: { type: EWarp.SPACE, value: {}}
    });

    t.snapshot(weave.toJSON());

    weave.add({
        foo: { value: {} }
    });
    
    t.snapshot(weave.toJSON());

    weave.destroy();
    t.snapshot(weave.toJSON());
});

test("warp/", t => {
    const weave = new Weave({
        name: "test",
        value: {
            hello: {
                value: {VISIBLE: {
                    sprite: [5]
                }}
            }
        },
        thread: {},
        rezed: []
    });

    const { hello } = weave.value.get();
    t.snapshot(hello.toJSON());
    weave.destroy();
});

test('warp/space', t => {
	const weave = new Weave({
		name: 'test',
		value: {
			hello: {
				value: {
					VISIBLE: {
						sprite: [5]
					}
				}
			}
		},
		thread: {},
		rezed: []
	});

	const hello = weave.value.get().hello; 

	hello.add({ DATA: { foo: 5 } });
	t.snapshot(hello.toJSON());

	const vis = hello.query('VISIBLE');
	t.snapshot(vis.toJSON());
	vis.add({
		foo: new Store(5)
	});

	t.snapshot(vis.get());
	vis.create();
	t.snapshot(vis.get());

	t.snapshot(weave.spaces.toJSON());
	weave.remove('hello');
	t.snapshot(weave.spaces.toJSON());
});

test('twist/visible', t => {
	Visible.data = new Buffer(Visible.defaults, 3);
	const weave = new Weave({
		name: 'test',
		thread: {},
		rezed: [],
		value: {
			test: {
				value: {
					VISIBLE: {
						sprite: [2]
					}
				}
			}
		}
	});

	t.snapshot(weave.toJSON());
	t.snapshot(Visible.data.toJSON());
});

test('twist/data', t => {
	const weave = new Weave({
		name: 'test',
		thread: {},
		rezed: [],
		value: {
			test: {
				value: {
					DATA: {
						arbitrary: 'hello'
					}
				}
			}
		}
	});

	t.snapshot(weave.toJSON());

	const space = weave.value.query('test'); 
	const data = space.query('DATA');

	t.snapshot(data.toJSON());

	data.add({
		foo: '5'
	});

	t.snapshot(data.toJSON());
});

test('twist/physical', t => {
	const weave = new Weave({
		name: 'test',
		thread: {},
		rezed: [],
		value: {
			test: {
				value: {
					PHYSICAL: {
						position: [0, 0, 0]
					}
				}
			}
		}
	});

	t.snapshot(weave.toJSON(), `should have defaults`);
});

let tick_set;
const tick = new Read(0, (set) => {
	tick_set = set;
});

let last_tick = Date.now();
const TIME_TICK_RATE = new Store(100);

const frame = new Read([0, 0], (set) => {
	let old;
	
	const data = [0, 0];
	const frame_t = (ts) => {
		raf_1(frame_t);

		if (old === undefined) old = ts;

		data[0] = ts;
		data[1] = Math.round(ts - old);

		old = ts;
		const now = Date.now();
		if (now - last_tick >= TIME_TICK_RATE.get()) {
			last_tick = now;
			tick_set(tick.get() + 1);
		}

		set(data);
	};

	raf_1(frame_t);
});

var time = /*#__PURE__*/Object.freeze({
	__proto__: null,
	tick: tick,
	TIME_TICK_RATE: TIME_TICK_RATE
});

// TODO: maybe an input one that gets written to from client?

test('sys/time', t => {
	t.snapshot(TIME_TICK_RATE.get());
});

class Wheel extends Living {
	 __init() {this.value = new Tree({
		sys: new Weave({
			name: `sys`,
			thread: {},
			value: {},
			rezed: []
		})
	});}

	constructor(wheel_data) {
		super();Wheel.prototype.__init.call(this);

		this.rezed = new Store(new Set(wheel_data.rezed));

		this.add(wheel_data.value);
	}

	add(weaves, silent = false) {
		const write = {};

		for (let [name, value] of Object.entries(weaves)) {
			if (value instanceof Weave) {
				write[name] = value;
				continue
			}

			value.name = name;
			write[name] = new Weave(value);
		}

		super.add(write, silent);
	}
}

const simple = {
    rezed: ["test"],
    value: {
        test: {
            thread: {},
            rezed: ["test"],
            value: {
                test: {
                    type: EWarp.SPACE,
                    value: {
                        VISIBLE: {
                            sprite: [ 55 ]
                        }
                    }
                }
            }

        }
    }
};

test("wheel/", t => {
    const wheel = new Wheel(simple);

    t.snapshot(wheel.toJSON(), "loads");
    
    
});

class Messenger  {
	

	onmessage(event) {
		const msg = event.data;
		const fn = `msg_${msg.name}`;
		if (this[fn]) this[fn](msg.data);
	}

	postMessage(message) {
		this.remote.onmessage({ data: message });
	}
}

class RemoteGoblin extends Messenger {
	 __init() {this.wheel = new Wheel({
		rezed: [],
		value: {}
	});}
	
	
	constructor(remote) {
		super();RemoteGoblin.prototype.__init.call(this);
		this.remote = remote;

		raf_1(() => {
			this.postMessage({
				name: 'ready'
			});
		});
	}

	 tick() {
		raf_1(() => {
			this.postMessage({
				name: 'buffer',
				data: {
					VISIBLE: Visible.data.toJSON()
				}
			});
		});
	}

	 msg_toJSON() {
		this.postMessage({
			name: 'toJSON',
			data: this.wheel.toJSON()
		});
	}

	 msg_add(data) {
		if (data.value) this.wheel.add(data.value);

		if (data.rezed === undefined) return

		for (const name of data.rezed) {
			this.wheel.start(name);
		}
	}

	 msg_status(data) {
		this.wheel[data]();
		if (data !== ELivingAction.DESTROY) return

		this.postMessage({
			name: 'destroy'
		});
	}

	 msg_start(data) {
		this.wheel.start(data);
	}

	 msg_stop(data) {
		this.wheel.stop(data);
	}

	 msg_update(data) {
		this.wheel.ensure(data.path[0], ...data.path.slice(1)).set(data.value);
	}

	 msg_relay() {
		if (this.timeout) this.timeout();
		this.timeout = this.wheel
			.query('sys', 'time', 'tick')
			.listen(this.tick.bind(this));
	}

	 msg_grok() {
		if (this.cancel_grok) return
		this.cancel_grok = this.wheel.grok(
			(action, key, value) => {
				this.postMessage({
					name: 'groker',
					data: {
						action,
						key,
						value
					}
				});
			}
		);
	}

	 msg_grok_stop() {
		if (!this.cancel_grok) return
		this.cancel_grok();
	}
}

class LocalWorker extends Messenger  {constructor(...args) { super(...args); LocalWorker.prototype.__init.call(this); }
	 __init() {this.remote = new RemoteGoblin(this);}

	terminate() {
		// okay
	}

	onerror(ev) {
		// okay
	}
}

class Goblin extends Living {
	// this could use sharedmemory but not everyone supports it
	__init2() {this.buffer = new Tree({
		VISIBLE: Visible.data
	});}

	// convert to an inactive wheel
	__init3() {this.value = new Wheel({
		value: {},
		rezed: []
	});}

	
	
	 __init4() {this.sys_cancels = {};}
	
	
	

	 __init5() {this.json_resolvers = [];}

	constructor(sys, local = false) {
		super();Goblin.prototype.__init2.call(this);Goblin.prototype.__init3.call(this);Goblin.prototype.__init4.call(this);Goblin.prototype.__init5.call(this);Goblin.prototype.__init6.call(this);

		// doesn't guarantee syncing
		this.sys = sys;
		this.local = local;
		this.grokers = new Set();
		this.value.stop();
	}

	create() {
		this.worker = this.local
			? new LocalWorker()
			: new Worker(`/bin/goblin.bundle.js`);

		this.worker.onmessage = this.onmessage.bind(this);
		this.worker.onerror = this.onerror.bind(this);

		this.worker.postMessage({
			name: 'status',
			data: ELivingAction.CREATE
		});
	}

	rez() {
		this.sys_cancel = this.sys.listen(this.sys_update.bind(this));

		this.worker.postMessage({
			name: 'status',
			data: ELivingAction.REZ
		});
	}

	derez() {
		for (let cancel of Object.values(this.sys_cancels)) {
			cancel();
		}

		this.sys_cancel();

		this.worker.postMessage({
			name: 'status',
			data: ELivingAction.DEREZ
		});
	}

	destroy() {
		this.worker.postMessage({
			name: 'status',
			data: ELivingAction.DESTROY
		});

		if (this.grokers.size > 0) {
			this.worker.postMessage({
				name: 'grok_stop'
			});

			this.grokers.clear();
		}
	}

	// replicate system changes into the worker
	 sys_update($sys) {
		// this should happen very rarely
		for (let cancel of Object.values(this.sys_cancels)) {
			cancel();
		}

		this.sys_cancels = {};

		for (let [name, category] of Object.entries($sys)) {
			this.sys_cancels[name] = category.listen($category => {
				for (let [key, store] of Object.entries($category)) {
					this.sys_cancels[`${name}/${key}`] = store.listen(
						$store => {
							this.worker.postMessage({
								name: 'update',
								data: {
									path: [`sys`, name, key],
									value: $store
								}
							});
						}
					);
				}
			});
		}
	}

	 msg_destroy() {
		this.worker.terminate();
	}

	 msg_groker({ action, key, value }) {
		// hydrate self
		this.value.groker(action, key, value);
	}

	 msg_toJSON(json) {
		for (let resolve of this.json_resolvers) {
			resolve(json);
		}
	}

	 msg_buffer(data) {
		for (let [name, buffer] of Object.entries(data)) {
			const buff = this.buffer.query(name);

			if (buff === undefined) return
			buff.hydrate(buffer);
		}

		this.buffer.notify();
	}

	 msg_ready() {
		this.worker.postMessage({
			name: 'relay'
		});
	}

	 __init6() {this.onmessage = Messenger.prototype.onmessage;}

	 onerror(event) {
		console.error(`Worker Error`, event);
	}

	async remote_toJSON() {
		return new Promise(resolve => {
			this.json_resolvers.push(resolve);

			if (this.json_resolvers.length !== 1) return

			this.worker.postMessage({
				name: 'toJSON'
			});
		})
	}

	add(data) {
		this.worker.postMessage({
			name: 'add',
			data
		});
	}

	start(data) {
		this.worker.postMessage({
			name: 'start',
			data
		});
	}

	stop(data) {
		this.worker.postMessage({
			name: 'stop',
			data
		});
	}

	remote_grok() {
		if (this.grokers.size === 0) {
			this.worker.postMessage({
				name: 'grok'
			});
		}
		const groker = this.groker.bind(this);

		this.grokers.add(groker);

		return () => {
			this.grokers.delete(groker);

			if (this.grokers.size === 0) {
				this.worker.postMessage({
					name: 'grok_stop'
				});
			}
		}
	}
}

TIME_TICK_RATE.set(10);

test('goblin/', async t => {
	const worker = new Goblin(
		new Tree({
			test: new Tree({
				1: new Store(5)
			}),
			time: new Tree(time)
		}),
		true
	);

	worker.create();
	worker.rez();

	t.snapshot(worker.sys.toJSON(), 'sys available');
	t.snapshot(worker.toJSON(), 'local worker');

	worker.add(simple);

	// forces a dump
	t.snapshot(await worker.remote_toJSON(), 'remote worker');

	let count = 0;
	const cancel_grok = worker.remote_grok();

	await new Promise(resolve => {
		const cancel = worker.buffer.listen($buffer => {
			t.snapshot($buffer.VISIBLE.toJSON(), 'visible');

			if (count++ < 4) return
			cancel();
			resolve();
		});
	});

	cancel_grok();

	t.snapshot(worker.value.toJSON(), 'local remote json post grok');
});

// Starts up in the main thread
class Isekai extends Living {
	 __init() {this.goblins = new Tree();}
	 __init2() {this.value = this.goblins;}

	 __init3() {this.sys = new Tree();}
	 __init4() {this.local = new Store(false);}

	constructor(sys, local = false) {
		super();Isekai.prototype.__init.call(this);Isekai.prototype.__init2.call(this);Isekai.prototype.__init3.call(this);Isekai.prototype.__init4.call(this);
		this.local.set(local);

		const write = {};
		for (let [name, value] of Object.entries(sys)) {
			write[name] = new Tree(value);
		}

		this.sys.add(write);

		// Check Path
		// Check Database
		this.create();
		this.rez();
	}

	add(wheels) {
		const write = {};

		for (let [name, wheel_json] of Object.entries(wheels)) {
			const worker = (write[name] = new Goblin(
				this.sys,
				this.local.get()
			));

			worker.create();
			worker.add(wheel_json);
		}

		super.add(write);
	}
}

test('isekai/', t => {
	const isekai = new Isekai(
		{
			test: {
				there: new Store(1)
			},
			time
		},
		true
	);

	t.snapshot(isekai.toJSON(), 'base snapshot');
	t.snapshot(isekai.sys.query('test', 'there').get(), 'system is available');

	isekai.add({ simple });

	t.snapshot(isekai.toJSON(), 'added simple');

	isekai.add({
		blank: {
			rezed: [],
			value: {}
		}
	});

	t.snapshot(isekai.toJSON(), 'added blank');
});
//# sourceMappingURL=bundle.test.js.map

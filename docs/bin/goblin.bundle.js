(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var performanceNow = createCommonjsModule(function (module) {
	// Generated by CoffeeScript 1.12.2
	(function() {
	  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

	  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
	    module.exports = function() {
	      return performance.now();
	    };
	  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
	    module.exports = function() {
	      return (getNanoSeconds() - nodeLoadTime) / 1e6;
	    };
	    hrtime = process.hrtime;
	    getNanoSeconds = function() {
	      var hr;
	      hr = hrtime();
	      return hr[0] * 1e9 + hr[1];
	    };
	    moduleLoadTime = getNanoSeconds();
	    upTime = process.uptime() * 1e9;
	    nodeLoadTime = moduleLoadTime - upTime;
	  } else if (Date.now) {
	    module.exports = function() {
	      return Date.now() - loadTime;
	    };
	    loadTime = Date.now();
	  } else {
	    module.exports = function() {
	      return new Date().getTime() - loadTime;
	    };
	    loadTime = new Date().getTime();
	  }

	}).call(commonjsGlobal);

	//# sourceMappingURL=performance-now.js.map
	});

	var root = typeof window === 'undefined' ? commonjsGlobal : window
	  , vendors = ['moz', 'webkit']
	  , suffix = 'AnimationFrame'
	  , raf = root['request' + suffix]
	  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

	for(var i = 0; !raf && i < vendors.length; i++) {
	  raf = root[vendors[i] + 'Request' + suffix];
	  caf = root[vendors[i] + 'Cancel' + suffix]
	      || root[vendors[i] + 'CancelRequest' + suffix];
	}

	// Some versions of FF have rAF but not cAF
	if(!raf || !caf) {
	  var last = 0
	    , id = 0
	    , queue = []
	    , frameDuration = 1000 / 60;

	  raf = function(callback) {
	    if(queue.length === 0) {
	      var _now = performanceNow()
	        , next = Math.max(0, frameDuration - (_now - last));
	      last = next + _now;
	      setTimeout(function() {
	        var cp = queue.slice(0);
	        // Clear queue here to prevent
	        // callbacks from appending listeners
	        // to the current frame's queue
	        queue.length = 0;
	        for(var i = 0; i < cp.length; i++) {
	          if(!cp[i].cancelled) {
	            try{
	              cp[i].callback(last);
	            } catch(e) {
	              setTimeout(function() { throw e }, 0);
	            }
	          }
	        }
	      }, Math.round(next));
	    }
	    queue.push({
	      handle: ++id,
	      callback: callback,
	      cancelled: false
	    });
	    return id
	  };

	  caf = function(handle) {
	    for(var i = 0; i < queue.length; i++) {
	      if(queue[i].handle === handle) {
	        queue[i].cancelled = true;
	      }
	    }
	  };
	}

	var raf_1 = function(fn) {
	  // Wrap in a new function to prevent
	  // `cancel` potentially being assigned
	  // to the native rAF function
	  return raf.call(root, fn)
	};
	var cancel = function() {
	  caf.apply(root, arguments);
	};
	var polyfill = function(object) {
	  if (!object) {
	    object = root;
	  }
	  object.requestAnimationFrame = raf;
	  object.cancelAnimationFrame = caf;
	};
	raf_1.cancel = cancel;
	raf_1.polyfill = polyfill;

	// Stores are observables
	class Store  {
		
		

		constructor(value) {
			this.value = value;
		}

		notify () {
			if (!this.listeners) return
			this.listeners.forEach((listener) => listener(this.value));
		}

		subscribe (listener) {
			return this.listen(listener)
		}

		listen (listener, no_initial = false)  { 
			if (!this.listeners) this.listeners = new Set();

			this.listeners.add(listener);
			
			if (!no_initial) listener(this.get());

			return () => this.listeners.delete(listener)
		}

		get ()  { return this.value }
		
		set (value, silent = false) {
			this.value = value;
			if(silent) return
			
			this.notify();
		}

		update (updator) {
			this.set(updator(this.value));
		}

		toJSON ()  {
			switch (typeof this.value) {
			case `undefined`:
			case `number`:
			case `string`:
				return this.value 

			case `object`:
				if(Set.prototype.isPrototypeOf(this.value)) {
					return Array.from(this.value)
				}

				if (
					Array.isArray(this.value) ||
					this.value === null
				) {
					return this.value
				}
				
				if (this.value.toJSON) {
					return this.value.toJSON()
				}
			}

			return JSON.parse(
				JSON.stringify(this.value)
			)
		}
	}

	class Read extends Store {
	    constructor(value, setter) {
	        super(value);

	        if(setter) setter(Store.prototype.set.bind(this));
	    }

	     p_set(value, silent = false) {
	        super.set(value, silent);
	    }

	    set(value, silent = false) {
	        return
	    }
	}

	var EGrok; (function (EGrok) {
		const ADD = 0; EGrok[EGrok["ADD"] = ADD] = "ADD";
		const REMOVE = ADD + 1; EGrok[EGrok["REMOVE"] = REMOVE] = "REMOVE";
		const UPDATE = REMOVE + 1; EGrok[EGrok["UPDATE"] = UPDATE] = "UPDATE";
	})(EGrok || (EGrok = {}));


















	class Tree extends Read {
		

		constructor(tree = {}, setter) {
			super(tree, setter);
		}

		item(name) {
			return super.get()[name]
		}

		has(name) {
			return this.item(name) !== undefined
		}

		reset(target, silent = false) {
			const $tree = {};
			if (target) {
				Object.assign($tree, target);
			}

			this.p_set($tree, silent);
		}

		add(tree_json, silent = false) {
			const $tree = this.get();

			Object.assign($tree, tree_json);

			this.p_set($tree, silent);

			return tree_json
		}

		remove(name, silent = false) {
			delete this.value[name];
			if (!silent) this.notify();
		}

		query(...steps) {
			const cursor = this.value[steps.shift()]; 

			if (steps.length === 0 || !cursor) return cursor
			return cursor.query(...steps)
		}

		count() {
			return Object.keys(this.get()).length
		}

		groker(action, path, value) {
			switch (action) {
				case EGrok.ADD:
				case EGrok.REMOVE:
				case EGrok.UPDATE:
			}
		}

		grok(groker) {
			const cancels = {};

			let last = [];

			cancels[''] = this.listen($value => {
				// value changed
				for (let key of last) {
					if ($value[key] === undefined) {
						groker(EGrok.REMOVE, key);
					}
				}

				last = Object.keys($value);

				for (let [key, child] of Object.entries($value)) {
					if (cancels[key]) return
					groker(EGrok.ADD, key);

					const cx = child; 
					// tree
					if (cx.grok) {
						cancels[key] = cx.grok((action, k, v) =>
							groker(action, `${key}/${k}`, v)
						);
						continue
					}

					// store (updates)
					if (cx.listen) {
						cancels[key] = cx.listen(v => groker(EGrok.UPDATE, key, v));
						continue
					}
				}
			});

			return () => {
				for (let cancel of Object.values(cancels)) {
					cancel();
				}
			}
		}
	}

	class Proxy {
		

		get() {
			return this.value.get()
		}
		listen(listen) {
			return this.value.listen(listen)
		}
		set(value, silent = false) {
			this.value.set(value, silent);
		}
		toJSON() {
			return this.value.toJSON()
		}
		notify() {
			this.value.notify();
		}

		subscribe(listen) {
			return this.listen(listen)
		}
	}

	class ProxyTree extends Proxy
	 {
		

		item(name) {
			return this.value.item(name)
		}

		reset(target, silent) {
			return this.value.reset(target, silent)
		}

		add(tree_write, silent) {
			return this.value.add(tree_write, silent)
		}

		remove(name, silent) {
			this.value.remove(name, silent);
		}

		query(...steps) {
			return this.value.query(...steps)
		}

		has(name) {
			return this.item(name) !== undefined
		}

		grok(groker) {
			return this.grok(groker)
		}
	}

	class BufferValue extends Store {
	    set (value, silent = false) {
	        this.get().set(value);
	        if(silent === false) this.notify();
	    }
	}

	class Buffer extends Tree {
	    
	    
	    
	    

	     create_data (size) {
	        const data = {};
	        
	        for(let key of Object.keys(this.defaults)) {
	            data[key] = new Float32Array(this.defaults[key].length * size);

	            // copy existing data
	            if(this.value && Object.keys(this.value).length > 0) {
	                data[key].set(this.value[key]);
	            }
	        }
	        
	        if(this.available) {
	            const additions = Array.from(Array(size - this.count).keys()).map(i => i + this.count);
	            this.available = new Set([...Array.from(this.available), ...additions]);
	        } else {
	            this.available = new Set(Array(size).keys());
	        }

	        this.value = data;
	        this.count = size;
	    }

	    constructor (defaults, initial_size = 100) {
	        super();

	        this.defaults = defaults;
	        this.create_data(initial_size);
	    }
	    
	    allocates (...data)  {
	        const results = [];
	        for(let datum of data) {
	            results.push(this.allocate(datum));
	        }

	        return results
	    }

	    allocate (datum)  {
	        const buffer_view = {};
	        let cursor = this.available.values().next().value;
	        if(cursor === undefined) {
	            this.resize();
	            cursor = this.available.values().next().value;
	        }

	        this.available.delete(cursor);

	        for(let key of Object.keys(this.defaults)) {
	            const len = this.defaults[key].length;
	            const idx = cursor * len; 
	            const view = this.value[key].subarray(idx, idx + len);

	            view.set(datum[key] ? datum[key] : this.defaults[key]);

	            buffer_view[key] = new BufferValue(view);
	        }

	        return [buffer_view, cursor]
	    }

	    free (idx) {
	        this.available.add(idx);

	        for(let key of Object.keys(this.defaults)) {    
	            const len = this.defaults[key].length;
	            this.value[key].set(Array(len).fill(0), len * idx);
	        }
	    }

	    resize (size) {
	        if(size === undefined) size = this.count * 2;
	        if(size < this.count) throw new Error("cannot reduce the size of a buffer")

	        this.create_data(size);
	        this.notify();
	    }

	    hydrate (data) {
	        for(let key of Object.keys(this.value)) {
	            this.value[key].set(data[key]);
	        }

	        this.notify();
	    }

	    toJSON ()  {
	        const json = {};
	        for(let key of Object.keys(this.value)) {
	            json[key] = this.value[key];
	        }

	        return json
	    }
	}

	var ELivingAction; (function (ELivingAction) {
		const CREATE = 'create'; ELivingAction["CREATE"] = CREATE;
		const REZ = 'rez'; ELivingAction["REZ"] = REZ;
		const DEREZ = 'derez'; ELivingAction["DEREZ"] = DEREZ;
		const DESTROY = 'destroy'; ELivingAction["DESTROY"] = DESTROY;
	})(ELivingAction || (ELivingAction = {}));

	var ELivingStatus; (function (ELivingStatus) {
		const VOID = 'VOID'; ELivingStatus["VOID"] = VOID;
		const CREATED = 'CREATED'; ELivingStatus["CREATED"] = CREATED;
		const REZED = 'REZED'; ELivingStatus["REZED"] = REZED;
	})(ELivingStatus || (ELivingStatus = {}));

	class Living extends ProxyTree {constructor(...args) { super(...args); Living.prototype.__init.call(this); }
		
		 __init() {this.status = new Store(ELivingStatus.VOID);}

		add(living_data, silent = false) {
			super.add(living_data, silent);
			const $status = this.status.get();
			const items = Object.entries(living_data);

			switch ($status) {
				case ELivingStatus.CREATED:
					for (let [_, item] of items) {
						item.create && item.create();
					}

				case ELivingStatus.REZED:
					const $rezed = this.rezed && this.rezed.get();

					// create doesn't auto rez
					// so you can batch creates together then rez
					for (let [name, item] of items) {
						if ($rezed && !$rezed[name]) continue
						item.rez && item.rez();
					}
			}
		}

		remove(name, silent = false) {
			const $value = this.get(); 

			if ($value[name] && $value[name].destroy) {
				$value[name].destroy();
			}

			const $rezed = this.rezed && this.rezed.get();
			if ($rezed) {
				$rezed.delete(name);
			}

			super.remove(name, silent);
		}

		removes(...names) {
			for (let name of names) {
				this.remove(name, true);
			}

			this.notify();
		}

		create() {
			if (this.status.get() !== ELivingStatus.VOID) {
				throw new Error('Tried to create a nonvoid living class')
			}

			// run through my tree to guarantee its destroyed
			let sub;
			for (sub of Object.values(this.get())) {
				sub.create && sub.create();
			}

			this.status.set(ELivingStatus.CREATED);
		}

		destroy() {
			if (this.status.get() === ELivingStatus.REZED) {
				this.derez();
			}

			let sub;
			for (sub of Object.values(this.get())) {
				sub.destroy && sub.destroy();
			}

			this.status.set(ELivingStatus.VOID);
		}

		rez() {
			if (this.status.get() === ELivingStatus.VOID) {
				this.create();
			}

			const rezed = this.rezed && this.rezed.get();

			for (let [name, sub] of Object.entries(this.get())) {
				if (rezed && !rezed.has(name)) continue
				;(sub ).rez && (sub ).rez();
			}

			this.status.set(ELivingStatus.REZED);
		}

		derez() {
			if (this.status.get() !== ELivingStatus.REZED) {
				return
			}

			const $rezed = this.rezed && this.rezed.get();

			for (let [name, sub] of Object.entries(this.get())) {
				if ($rezed && !$rezed.has(name)) continue
				;(sub ).derez && (sub ).derez();
			}

			this.status.set(ELivingStatus.CREATED);
		}

		start_all(...all) {
			all = all.length === 0 ? Object.keys(this.get()) : all;
			for (let name of all) {
				this.start(name);
			}
		}

		start(name) {
			const $rezed = this.rezed && this.rezed.get();
			const item = this.item(name);

			if (!item) return

			// can only rez if I am
			if (this.status.get() === ELivingStatus.REZED) {
	(item ).rez && (item ).rez();
			}

			if ($rezed) {
				$rezed.add(name);
				this.rezed.notify();
			}
		}

		stop(...names) {
			const $rezed = this.rezed && this.rezed.get();
			for (let name of names) {
				const item = this.item(name);
				if (!item) continue // can derez whenever though

				;(item ).derez && (item ).derez();

				if (!$rezed) continue

				$rezed.delete(name);
			}

			this.rezed.notify();
		}

		restart(name) {
			this.stop(name);
			this.start(name);
		}

		toJSON() {
			return {
				value: this.value.toJSON(),
				rezed: this.rezed ? this.rezed.toJSON() : undefined
			}
		}

		ensure(first, ...path) {
			let $item = this.item(first);

			if ($item === undefined) {
				this.add({
					[first]: {}
				});

				$item = this.item(first);
			}

			if (path.length === 0) return $item

			if ($item instanceof Living) {
				return $item.ensure(path[0], ...path.slice(1))
			}

			throw new Error('tried to ensure non living item')
		}
	}

	var EWarp; (function (EWarp) {
	    const SPACE = "SPACE"; EWarp["SPACE"] = SPACE;
	    const MATH = "MATH"; EWarp["MATH"] = MATH;
	    const VALUE = "VALUE"; EWarp["VALUE"] = VALUE;
	    const MAIL = "MAIL"; EWarp["MAIL"] = MAIL;
	})(EWarp || (EWarp = {}));

	class Warp extends Living {
	    
	    

	    

	    constructor (data, weave) {
	        super();

	        this.name = data.name;
	        this.type = data.type;
	        this.weave = weave;
	        
	        // don't init value because who knows what they want
	    }

	    toJSON () {
	        return {
	            name: this.name,
	            type: this.type,
	            value: this.value.toJSON()
	        }
	    }
	}

	var ETwist; (function (ETwist) {
	    const VISIBLE = "VISIBLE"; ETwist["VISIBLE"] = VISIBLE;
	    const PHYSICAL = "PHYSICAL"; ETwist["PHYSICAL"] = PHYSICAL;
	    const DATA = "DATA"; ETwist["DATA"] = DATA;
	})(ETwist || (ETwist = {}));





	class Twist extends Living {
	    
	    
	    
	    
	    constructor (weave, space) {
	        super();

	        this.space = space;
	        this.weave = weave;
	        this.value = new Tree({});
	    }

	    add (data, silent = false) {
	        const write = {};
	        for(let [name, value] of Object.entries(data)) {
	            if(value instanceof Store) {
	                write[name] = value;
	            } else {
	                write[name] = new Store(value);
	            }
	        }

	        super.add(write, silent);
	    }

	    toJSON () {
	        return this.value.toJSON()
	    }
	}

	// Visible spaces
	class Visible extends Twist { 
	    static __initStatic() {this.defaults = { 
	        position: [0, 0, 0],
	        sprite: [0],
	        scale: [1],
	        color: [255, 255, 255, 1],
	        rotation: [0]
	    };}

	    static __initStatic2() {this.data = new Buffer(Visible.defaults);}

	    

	    constructor(weave, space, visible_data) {
	        // set the views
	        super(weave, space);
	        const [view, idx] = Visible.data.allocate(visible_data);
	        this.index = idx;
	        this.add(view);
	    }

	    toJSON() {
	        const json = {};
	        const $value = this.get();
	        for(let key of Object.keys($value)) {
	            const $item = $value[key].get();

	            json[key] = Array.from($item);
	        }

	        return json
	    }
	} Visible.__initStatic(); Visible.__initStatic2();

	class Data extends Twist  {
	    constructor(weave,  space, data) {
	        super(weave, space);
	        this.add(data);
	    }
	}

	class Physical extends Twist {
	    constructor(weave, space, physical_data = {}) {
	        super(weave, space);
	        this.add(physical_data);
	    }
	}

	class Space extends Warp {
	     __init() {this.value = new Tree();}

	    constructor (warp_data, weave) {
	        super(warp_data, weave);Space.prototype.__init.call(this);

	        this.add(warp_data.value || {});
	    }

	    add (data) {
	        const adds = {};

	        for(let type of Object.keys(data)) {
	            adds[type] = this.create_twist(type, data[type]);
	        }

	        super.add(adds);
	    }

	     create_twist (type, twist_data = {}) {
	        switch(type) {
	            case ETwist.DATA:
	                return new Data(this.weave, this, twist_data)
	            case ETwist.VISIBLE: 
	                return new Visible(this.weave, this, twist_data )
	            case ETwist.PHYSICAL:
	                return new Physical(this.weave, this, twist_data )
	        }

	        return new Store(twist_data)
	    }   

	    create () {
	        super.create();
	        this.weave.spaces.add({ [this.name]: this });
	    }

	    destroy () {
	        super.destroy();
	        this.weave.spaces.remove(this.name);
	    }
	}

	class Weave extends Living {
	    
	    
	     __init() {this.value = new Tree({});}

	    // caches
	    
	     __init2() {this.spaces = new Tree({});}

	    // clean up
	      __init3() {this.cancels = new Set();}
	     
	     __init4() {this.nerves = {};}

	    create_warp ($warp) {
	        switch($warp.type) {
	            case undefined:
	                $warp.type = EWarp.SPACE;
	            case EWarp.SPACE:
	                 return new Space($warp, this)
	            case EWarp.MAIL:
	            case EWarp.VALUE:
	            case EWarp.MATH:
	        }

	        throw new Error(`warp/unknown ${$warp}`)
	    }

	    constructor (data) {
	        super();Weave.prototype.__init.call(this);Weave.prototype.__init2.call(this);Weave.prototype.__init3.call(this);Weave.prototype.__init4.call(this); 

	        if(data.name === undefined) {
	            throw new Error("Undefined name for weave")
	        }

	        this.name = new Store(data.name);
	        this.threads = new Tree(data.thread || {});
	        this.rezed = new Store(new Set(data.rezed || []));

	        this.threads_reverse = new Tree({}, set => {
	            this.cancels.add(this.threads.listen(($threads) => {
	                const w_r = {};
	                for(let key of Object.keys($threads)) {
	                    w_r[$threads[key]] = key;
	                }

	                set(w_r);
	            }));
	        });

	        this.add(data.value || {});
	    }

	    add (warp_data, silent = false)  {
	        if(!warp_data) return
	        const warps = {};

	        for(let [name, warp] of Object.entries(warp_data)) {
	            if (warp instanceof Warp) {
	                warps[name] = warp;
	                continue
	            }

	            warp.name = name;
	            warps[name] = this.create_warp(warp);
	        }

	        super.add(warps, silent);

	        return warps
	    }

	    rez () {
	        super.rez();

	        // connect threads to form nerves
	        this.thread_cancel = this.threads.listen(this.thread_update.bind(this));
	    }

	    thread_update ($threads) {
	        for(let [name, cancel] of Object.entries(this.nerves)) {
	            if($threads[name]) {
	                delete $threads[name];
	                continue
	            }

	            cancel();
	            delete this.nerves[name];
	        }

	        for(let [from, to] of Object.entries($threads)) {
	            const f = this.query(...from.split("/"));
	            const t = this.query(...to.split("/"));
	            if(!f || !t) continue
	            this.nerves[from] = f.listen(t.set.bind(t));
	        }
	    }

	    derez () {
	        super.derez();
	        
	        for(let cancel of Object.values(this.nerves)) {
	            cancel();
	        }

	        this.thread_cancel();
	    }

	    removes (...names) {
	        const $warps = this.value.get();
	        const $wefts = this.threads.get();
	        const $wefts_r = this.threads_reverse.get();
	        const $rezed = this.rezed.get();

	        for(let name of names) {
	            const warp = $warps[name];
	            if(warp) warp.destroy();

	            delete $warps[name];
	            delete $wefts[name];
	            $rezed.delete(name);

	            const r = $wefts_r[name];
	            if(r) {
	                delete $wefts[r];
	            }
	        }

	        this.value.set($warps);
	        this.threads.set($wefts);
	        this.rezed.set($rezed);
	    }

	    remove (name) {
	        this.removes(name);
	    }

	    destroy() {
	        super.destroy();

	        for(let cancel of Array.from(this.cancels)) {
	            cancel();
	        }

	        this.cancels.clear();
	    }

	    toJSON () {
	        return {
	            name: this.name.get(),
	            thread: this.threads.get(),

	            value: this.value.toJSON(),
	            rezed: this.rezed.toJSON()
	        }
	    }
	}

	class Wheel extends Living {
		 __init() {this.value = new Tree({
			sys: new Weave({
				name: `sys`,
				thread: {},
				value: {},
				rezed: []
			})
		});}

		constructor(wheel_data) {
			super();Wheel.prototype.__init.call(this);

			this.rezed = new Store(new Set(wheel_data.rezed));

			this.add(wheel_data.value);
		}

		add(weaves, silent = false) {
			const write = {};

			for (let [name, value] of Object.entries(weaves)) {
				if (value instanceof Weave) {
					write[name] = value;
					continue
				}

				value.name = name;
				write[name] = new Weave(value);
			}

			super.add(write, silent);
		}
	}

	class Messenger  {
		

		onmessage(event) {
			const msg = event.data;
			const fn = `msg_${msg.name}`;
			if (this[fn]) this[fn](msg.data);
		}

		postMessage(message) {
			this.remote.onmessage({ data: message });
		}
	}

	class RemoteGoblin extends Messenger {
		 __init() {this.wheel = new Wheel({
			rezed: [],
			value: {}
		});}

		
		constructor(remote) {
			super();RemoteGoblin.prototype.__init.call(this);
			this.remote = remote;

			raf_1(() => {
				this.postMessage({
					name: 'ready'
				});
			});
		}

		 tick() {
			raf_1(() => {
				this.postMessage({
					name: 'buffer',
					data: {
						VISIBLE: Visible.data.toJSON()
					}
				});
			});
		}

		 msg_toJSON() {
			this.postMessage({
				name: 'toJSON',
				data: this.wheel.toJSON()
			});
		}

		 msg_add(data) {
			if (data.value) this.wheel.add(data.value);

			if (data.rezed === undefined) return

			for (const name of data.rezed) {
				this.wheel.start(name);
			}
		}

		 msg_status(data) {
			this.wheel[data]();
			if (data !== ELivingAction.DESTROY) return

			this.postMessage({
				name: 'destroy'
			});
		}

		 msg_start(data) {
			this.wheel.start(data);
		}

		 msg_stop(data) {
			this.wheel.stop(data);
		}

		 msg_update(data) {
			this.wheel.ensure(data.path[0], ...data.path.slice(1)).set(data.value);
		}

		 msg_relay() {
			if (this.timeout) this.timeout();
			this.timeout = this.wheel
				.query('sys', 'time', 'tick')
				.listen(this.tick.bind(this));
		}
	}

	const worker = new RemoteGoblin({
		onmessage(event) {
			postMessage(event.data);
		}
	});

	onmessage = worker.onmessage.bind(worker);

}());
//# sourceMappingURL=goblin.bundle.js.map

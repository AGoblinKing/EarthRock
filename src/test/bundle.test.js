'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var test = _interopDefault(require('ava'));

// Stores are observables
class Store  {
	
	

	constructor(value) {
		this.value = value;
	}

	notify () {
		if (!this.listeners) return
		this.listeners.forEach((listener) => listener(this.value));
	}

	subscribe (listener) {
		return this.listen(listener)
	}

	listen (listener, no_initial = false)  { 
		if (!this.listeners) this.listeners = new Set();

		this.listeners.add(listener);
		
		if (!no_initial) listener(this.get());

		return () => this.listeners.delete(listener)
	}

	get ()  { return this.value }
	
	set (value, silent = false) {
		this.value = value;
		if(silent) return
		
		this.notify();
	}

	update (updator) {
		this.set(updator(this.value));
	}

	toJSON ()  {
		switch (typeof this.value) {
		case `undefined`:
		case `number`:
		case `string`:
			return this.value 

		case `object`:
			if(Set.prototype.isPrototypeOf(this.value)) {
				return Array.from(this.value)
			}

			if (
				Array.isArray(this.value) ||
				this.value === null
			) {
				return this.value
			}
			
			if (this.value.toJSON) {
				return this.value.toJSON()
			}
		}

		return JSON.parse(
			JSON.stringify(this.value)
		)
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);


});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

test("store/store", t => {
    const s = new Store(5);
    t.snapshot(s.get());

    s.set(6);
    t.snapshot(s.get());

    s.update((i) => i + 1);
    t.snapshot(s.get());
});

test("store/observable", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.subscribe(($value) => {
            t.snapshot($value);

            raf_1(() => {
                cancel();
                s.set(7);
                resolve();
            });
        });
    });
});

test("store/listen/silent", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.listen(($value) => {
            t.snapshot($value);
            cancel();
            resolve();
        }, true);

        s.set(7);
    });
});

test("store/toJSON", t => {
    t.snapshot(new Store({"foo": "bar"}).toJSON());
    t.snapshot(new Store(5).toJSON());
    t.snapshot(new Store([5, 5]).toJSON());
    t.snapshot(new Store(new Store(5)).toJSON());
});

test("store/set/silent", t => {
    t.plan(1);
    const store = new Store(5);
    store.listen(($value) => {
        t.pass();
    }, true);

    store.set(6, true);
    store.set(7);
});

class Read extends Store {
    constructor(value, setter) {
        super(value);

        if(setter) setter(Store.prototype.set.bind(this));
    }

     p_set(value, silent = false) {
        super.set(value, silent);
    }

    set(value, silent = false) {
        return
    }
}

class Tree extends Read {
	

	constructor(tree = {}, setter) {
		super(tree, setter);
	}

	item (name) {
		return super.get()[name]
	}

	has (name) {
		return this.item(name) !== undefined
	}

	reset (target, silent = false) {
		const $tree = {};
		if(target) {
			Object.assign($tree, target);
		}

		this.p_set($tree, silent);
	}

	add (tree_json, silent = false) {
		const $tree = this.get();
		Object.assign($tree, tree_json);

		this.p_set($tree, silent);
	}

	remove (name, silent = false) {
		delete this.value[name];
		if(!silent) this.notify();
	}
	
	query (...steps)  {
		
		const cursor = this.value[steps.shift()]; 

		if(steps.length === 0 || !cursor) return cursor 	
		return cursor.query(...steps)
	}
}

test("store/tree", t => {
    const tree = new Tree({
        foo: 1,
        bar: "2",
        store: new Store(5),
        stores: new Store(new Store("string"))
    });

    t.snapshot(tree.get());
});

test("store/tree/names", t => {
    const tree = new Tree({
        foo: 1,
        bar: "2",
        store: new Store(5),
        stores: new Store(new Store("string"))
    });

    tree.add({foo: 2});
    t.snapshot(tree.get());
    t.snapshot(tree.item("foo"));

    tree.add({
        foo: 5,
        store: 1,
        new_thing: "new"
    });

    t.snapshot(tree.get());
    t.snapshot(tree.toJSON());

    tree.remove("store");

    t.snapshot(tree.get());
});



test("store/tree/query", t => {
    const tree = new Tree({
        foo: 1,
        nest: new Tree({
            deeper: new Tree({
                final: 3
            }),
            mid: 2
        })
    });

    t.snapshot(tree.query("foo"));
    t.snapshot(tree.query("nest"));
    t.snapshot(tree.query("nest", "mid"));
    t.snapshot(tree.query("nest", "deeper"));
    t.snapshot(tree.query("nest", "deeper", "final"));
});

test("store/read", t => {
    t.plan(3);
    let setter;
    const read = new Read(5, set => {
        setter = set;
    });

    const cancel = read.listen(($value) => {
        t.true($value === 10);
        cancel();
    }, true);

    t.snapshot(read.get());
    read.set(6);
    t.snapshot(read.get());

    setter(10);
});

class Proxy {
    

    get() { return this.value.get() }
    listen(listen) { return this.value.listen(listen) }
    set(value, silent = false) { this.value.set(value, silent); }
    toJSON() { return this.value.toJSON() }
    notify() { this.value.notify(); }
}

class ProxyTree extends Proxy {
    
    
    item (name) {
        return this.value.item(name)
    }

    reset (target, silent)  {
        return this.value.reset(target, silent)
    }

    add (tree_write, silent) {
        return this.value.add(tree_write, silent)
    }

    remove (name, silent) {
        this.value.remove(name, silent);
    }

    query (...steps)  {
        return this.value.query(...steps)
    }
}

class BufferValue extends Store {
    set (value, silent = false) {
        this.get().set(value);
        if(silent === false) this.notify();
    }
}

class Buffer extends Tree {
    
    
    
    

     create_data (size) {
        const data = {};
        
        for(let key of Object.keys(this.defaults)) {
            data[key] = new Float32Array(this.defaults[key].length * size);

            // copy existing data
            if(this.value && Object.keys(this.value).length > 0) {
                data[key].set(this.value[key]);
            }
        }
        
        if(this.available) {
            const additions = Array.from(Array(size - this.count).keys()).map(i => i + this.count);
            this.available = new Set([...Array.from(this.available), ...additions]);
        } else {
            this.available = new Set(Array(size).keys());
        }

        this.value = data;
        this.count = size;
    }

    constructor (defaults, initial_size = 100) {
        super();

        this.defaults = defaults;
        this.create_data(initial_size);
    }
    
    allocates (...data)  {
        const results = [];
        for(let datum of data) {
            results.push(this.allocate(datum));
        }

        return results
    }

    allocate (datum)  {
        const buffer_view = {};
        let cursor = this.available.values().next().value;
        if(cursor === undefined) {
            this.resize();
            cursor = this.available.values().next().value;
        }

        this.available.delete(cursor);

        for(let key of Object.keys(this.defaults)) {
            const len = this.defaults[key].length;
            const idx = cursor * len; 
            const view = this.value[key].subarray(idx, idx + len);

            view.set(datum[key] ? datum[key] : this.defaults[key]);

            buffer_view[key] = new BufferValue(view);
        }

        return [buffer_view, cursor]
    }

    free (idx) {
        this.available.add(idx);

        for(let key of Object.keys(this.defaults)) {    
            const len = this.defaults[key].length;
            this.value[key].set(Array(len).fill(0), len * idx);
        }
    }

    resize (size) {
        if(size === undefined) size = this.count * 2;
        if(size < this.count) throw new Error("cannot reduce the size of a buffer")

        this.create_data(size);
        this.notify();
    }

    hydrate (data) {
        for(let key of Object.keys(this.value)) {
            this.value[key].set(data[key]);
        }

        this.notify();
    }

    toJSON ()  {
        const json = {};
        for(let key of Object.keys(this.value)) {
            json[key] = this.value[key];
        }

        return json
    }
}

var ELivingAction; (function (ELivingAction) {
    const CREATE = "create"; ELivingAction["CREATE"] = CREATE;
    const REZ = "rez"; ELivingAction["REZ"] = REZ;
    const DEREZ = "derez"; ELivingAction["DEREZ"] = DEREZ;
    const DESTROY = "destroy"; ELivingAction["DESTROY"] = DESTROY;
})(ELivingAction || (ELivingAction = {}));

var ELivingStatus; (function (ELivingStatus) {
    const VOID = "VOID"; ELivingStatus["VOID"] = VOID;
    const CREATED = "CREATED"; ELivingStatus["CREATED"] = CREATED;
    const REZED = "REZED"; ELivingStatus["REZED"] = REZED;
})(ELivingStatus || (ELivingStatus = {}));

class Living extends ProxyTree {constructor(...args) { super(...args); Living.prototype.__init.call(this); }
    
     __init() {this.status = new Store(ELivingStatus.VOID);}

    add (living_data, silent = false) {
        super.add(living_data, silent);
        const $status = this.status.get();

        const items = Object.entries(living_data);

        switch($status) {
            case ELivingStatus.CREATED:
                for(let [_, item] of items) {
                    item.create && item.create();
                }

            case ELivingStatus.REZED:
                const $rezed = this.rezed && this.rezed.get(); 

                // create doesn't auto rez
                // so you can batch creates together then rez
                for(let [name, item] of items) {
                    if($rezed && !$rezed[name]) continue 
                    item.rez && item.rez();
                }
        }
    }
    
    remove (name, silent = false) {
        const $value = this.get(); 

        if($value[name] && $value[name].destroy) {
            $value[name].destroy();
        }

        const $rezed = this.rezed && this.rezed.get(); 
        if($rezed) {
            $rezed.delete(name);
        }

        super.remove(name, silent);
    }
    
    removes(...names) {
        for(let name of names) {
            this.remove(name, true);
        }

        this.notify();
    }

    create () {
        if(this.status.get() !== ELivingStatus.VOID) {
            throw new Error("Tried to create a nonvoid living class")
        }

        // run through my tree to guarantee its destroyed
        let sub;
        for(sub of Object.values(this.get())) {
            sub.create && sub.create();
        }

        this.status.set(ELivingStatus.CREATED);
    }

    destroy () {
        if(this.status.get() === ELivingStatus.REZED) {
            this.derez();
        }

        let sub;
        for(sub of Object.values(this.get())) {
            sub.destroy && sub.destroy();
        }

        this.status.set(ELivingStatus.VOID);
    }
    
    rez () {
        if(this.status.get() === ELivingStatus.VOID) {
            this.create();
        }

        const rezed = this.rezed && this.rezed.get();        

        for(let [name, sub] of Object.entries(this.get())) {
            if(rezed && !rezed.has(name)) continue

            (sub ).rez && (sub ).rez();
        }

        this.status.set(ELivingStatus.REZED);
    }

    derez () {
        if(this.status.get() !== ELivingStatus.REZED) {
            return   
        }

        const $rezed = this.rezed && this.rezed.get();        

        for(let [name, sub] of Object.entries(this.get())) {
            if($rezed && !$rezed.has(name)) continue
            
            (sub ).derez && (sub ).derez();
        }

        this.status.set(ELivingStatus.CREATED);
    }

    start_all(...all) {
        all = all.length === 0 ? Object.keys(this.get()) : all;
        for(let name of all) {
            this.start(name);
        }
    }

    start(name) {
        const $rezed = this.rezed && this.rezed.get();        
        const item = this.item(name);

        if(!item) return

        // can only rez if I am 
        if(this.status.get() === ELivingStatus.REZED) {
            (item ).rez && (item ).rez();
        }

        if($rezed) {
            $rezed.add(name);
            this.rezed.notify();
        }
    }

    stop(name) {
        const item = this.item(name);
        if(!item) return

        // can derez whenever though
        (item ).derez && (item ).derez();

        const $rezed = this.rezed && this.rezed.get();   
        if(!$rezed) return
        
        $rezed.delete(name);
        this.rezed.notify();
    }

    restart (name) {
        this.stop(name);
        this.start(name);
    }

    toJSON()  {
        return {
            value: this.value.toJSON(),
            rezed: this.rezed ? this.rezed.toJSON() : undefined
        }
    }

    ensure (first, ...path) {
        let $item = this.item(first);

        if($item === undefined) {
            this.add({
                [first]: {}
            });

            $item = this.item(first);
        }

        if(path.length === 0) return $item
        
        if($item instanceof Living) {
            return $item.ensure(path[0], ...path.slice(1))
        }
        
        throw new Error("tried to ensure non living item")
    }
}

class Transformer extends Store {
    

    constructor(initial, transformer) {
        super(transformer(initial));
        this.transformer = transformer;
    }
    
    set (value) {
        super.set(this.transformer(value));
    }
}

test("store/buffer", t => {
    const buffer = new Buffer({
        test: [1, 2],
        2: [3, 4]
    }, 3);

    t.snapshot(buffer.toJSON());

    const [item, idx] = buffer.allocate({test: [0, 1]});
    
    t.snapshot(buffer.toJSON());
    t.snapshot(item.test.get());

    const test = item.test.get();
    test[0] = 5;
    item.test.notify();

    t.snapshot(buffer.toJSON());

    buffer.free(0);
    t.snapshot(buffer.toJSON());

    const [view, cursor] = buffer.allocate({test: [1, 2]});
    t.snapshot(view, "allocates a view");

    view.test.set([5, 6]);
    t.snapshot(view, "is setable");

    buffer.allocates({test: [3, 4]}, {test: [5, 6]}, {test: [7, 9]});

    t.snapshot(buffer.toJSON(), "allocates works, and resizes");

    buffer.resize();
    t.snapshot(buffer.toJSON(), "resizeable");

    buffer.hydrate({
        test: [50, 60],
        2: [50, 60]
    });

    t.snapshot(buffer.toJSON(), "hydratable");
});

class Test extends Living {
    constructor(count) {
        super();
        
        const $value = {};
        for(let i = 0; i < count; i++) {
            $value[`${i}`] = new Test(0);
        }

        this.value = new Tree($value);
        this.rezed = new Store(new Set(["1"]));
    }
}

test("store/living", t => {
    const tester = new Test(5);

    t.snapshot(tester);

    tester.create();

    t.snapshot(tester);

    tester.add({
        6: new Test(1)
    });

    t.snapshot(tester.toJSON());

    tester.remove("2");
    t.snapshot(tester);

    tester.start("6");

    t.snapshot(tester);

    tester.query("6").start("0");
    tester.rez();

    t.snapshot(tester);

    tester.derez();
    t.snapshot(tester);

    tester.start("0");
    tester.stop("6");

    tester.rez();

    t.snapshot(tester);

    tester.remove("0");
    t.snapshot(tester);

    tester.destroy();

    t.snapshot(tester);

    tester.create();
    tester.rez();

    t.snapshot(tester);

    t.snapshot(tester.query("6", "0"));
});

class TestProxy extends Proxy {constructor(...args) { super(...args); TestProxy.prototype.__init.call(this); }
    __init() {this.value = new Store(5);}
}

class TestProxyTree extends ProxyTree {constructor(...args2) { super(...args2); TestProxyTree.prototype.__init2.call(this); }
    __init2() {this.value = new Tree({
        test: 5,
        foo: 6
    });}
}

test("store/proxy", t => {
    const proxy = new TestProxy();

    t.snapshot(proxy.get());
    
    proxy.set(6);

    t.snapshot(proxy.toJSON());
});

test("store/proxy/tree", t => {
    const proxy = new TestProxyTree();

    t.snapshot(proxy.get());

    proxy.add({
        foos: 7
    });

    t.snapshot(proxy.toJSON());

    proxy.remove("foo");

    t.snapshot(proxy.get());
});

test("store/transformer", t => {
    const store = new Transformer(1, (i) => i + 1);

    t.snapshot(store.get());
    store.set(5);

    t.snapshot(store.get());
});

const TILE_COUNT = 1024;

const str_color = (str) => {
	if (!str) return `#111`

	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	let color = `#`;
	for (let i = 0; i < 3; i++) {
		const value = (hash >> (i * 8)) & 0xFF;
		color += (`00` + value.toString(16)).substr(-2);
	}
	
	return color
};

const color = str_color;

// whiskers on kittens
const words = [
	`groovy`, `cat`, `bird`, `dog`, `poop`, `cool`, `not`, `okay`, `great`, `terrible`, `wat`,
	`goblin`, `life`, `ferret`, `gregert`, `robert`, `zilla`, `red`, `shirt`, `pants`, `blue`,
	`luna`, `ember`, `embear`, `lunatic`, `boring`, `killa`, `notice`, `thank`, `tank`,
	`under`, `near`, `near`, `quaint`, `potato`, `egg`, `bacon`, `narwhal`, `lamp`, `stairs`, `king`,
	`tyrant`, `grave`, `dire`, `happy`, `amazing`, `terrific`, `terrible`, `good`, `boring`,
	`rip`, `hello`, `world`, `global`, `universal`, `television`, `computer`
];

const tile = (str) => {
	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	return `${Math.abs(hash) % TILE_COUNT}`
};

const random = (count) => Array
	.from(new Array(count))
	.map(() => words[Math.floor(Math.random() * words.length)])
	.join(`_`);

test("lib/text", t => {
    t.snapshot(tile("hello"));
    t.is(typeof random(2), "string");
});

const is_character = /[a-zA-Z]/;

const json = (value) => {
	if (typeof value !== `string`) return value

	if (value.indexOf(`.`) === -1 && value.indexOf(`,`) === -1) {
		const n = parseInt(value);
		if (typeof n === `number` && !isNaN(n)) {
			return n
		}
	}

	// is character
	if(value[0] !== undefined && is_character.test(value[0])) return value

	try {
		return JSON.parse(value) 
	} catch (ex) {
		return value
	}
};

test("lib/parse", t => {
    t.snapshot(json("5"));
    t.snapshot(json("5.9"));
    t.snapshot(json("hello"));
    t.snapshot(json("[5]"));
    t.snapshot(json("{\"5\": 5}"));
});

var EWarp; (function (EWarp) {
    const SPACE = "SPACE"; EWarp["SPACE"] = SPACE;
    const MATH = "MATH"; EWarp["MATH"] = MATH;
    const VALUE = "VALUE"; EWarp["VALUE"] = VALUE;
    const MAIL = "MAIL"; EWarp["MAIL"] = MAIL;
})(EWarp || (EWarp = {}));

class Warp extends Living {
    
    

    

    constructor (data, weave) {
        super();

        this.name = data.name;
        this.type = data.type;
        this.weave = weave;
        
        // don't init value because who knows what they want
    }

    toJSON () {
        return {
            name: this.name,
            type: this.type,
            value: this.value.toJSON()
        }
    }
}

var ETwist; (function (ETwist) {
    const VISIBLE = "VISIBLE"; ETwist["VISIBLE"] = VISIBLE;
    const PHYSICAL = "PHYSICAL"; ETwist["PHYSICAL"] = PHYSICAL;
    const DATA = "DATA"; ETwist["DATA"] = DATA;
})(ETwist || (ETwist = {}));





class Twist extends Living {
    
    
    
    
    constructor (weave, space) {
        super();

        this.space = space;
        this.weave = weave;
        this.value = new Tree({});
    }

    add (data, silent = false) {
        const write = {};
        for(let [name, value] of Object.entries(data)) {
            if(value instanceof Store) {
                write[name] = value;
            } else {
                write[name] = new Store(value);
            }
        }

        super.add(write, silent);
    }

    toJSON () {
        return this.value.toJSON()
    }
}

// Visible spaces
class Visible extends Twist { 
    static __initStatic() {this.defaults = { 
        position: [0, 0, 0],
        sprite: [0],
        scale: [1],
        color: [255, 255, 255, 1],
        rotation: [0]
    };}

    static __initStatic2() {this.data = new Buffer(Visible.defaults);}

    

    constructor(weave, space, visible_data) {
        // set the views
        super(weave, space);
        const [view, idx] = Visible.data.allocate(visible_data);
        this.index = idx;
        this.add(view);
    }

    toJSON() {
        const json = {};
        const $value = this.get();
        for(let key of Object.keys($value)) {
            const $item = $value[key].get();

            json[key] = Array.from($item);
        }

        return json
    }
} Visible.__initStatic(); Visible.__initStatic2();

class Data extends Twist  {
    constructor(weave,  space, data) {
        super(weave, space);
        this.add(data);
    }
}

class Physical extends Twist {
    constructor(weave, space, physical_data = {}) {
        super(weave, space);
        this.add(physical_data);
    }
}

class Space extends Warp {
     __init() {this.value = new Tree();}

    constructor (warp_data, weave) {
        super(warp_data, weave);Space.prototype.__init.call(this);

        this.add(warp_data.value || {});
    }

    add (data) {
        const adds = {};

        for(let type of Object.keys(data)) {
            adds[type] = this.create_twist(type, data[type]);
        }

        super.add(adds);
    }

     create_twist (type, twist_data = {}) {
        switch(type) {
            case ETwist.DATA:
                return new Data(this.weave, this, twist_data)
            case ETwist.VISIBLE: 
                return new Visible(this.weave, this, twist_data )
            case ETwist.PHYSICAL:
                return new Physical(this.weave, this, twist_data )
        }

        return new Store(twist_data)
    }   

    create () {
        super.create();
        this.weave.spaces.add({ [this.name]: this });
    }

    destroy () {
        super.destroy();
        this.weave.spaces.remove(this.name);
    }
}

// export * from "./mail"
// export * from "./value"

class Weave extends Living {
    
    
     __init() {this.value = new Tree({});}

    // caches
    
     __init2() {this.spaces = new Tree({});}

    // clean up
      __init3() {this.cancels = new Set();}
     
     __init4() {this.nerves = {};}

    create_warp ($warp) {
        switch($warp.type) {
            case undefined:
                $warp.type = EWarp.SPACE;
            case EWarp.SPACE:
                 return new Space($warp, this)
            case EWarp.MAIL:
            case EWarp.VALUE:
            case EWarp.MATH:
        }

        throw new Error(`warp/unknown ${$warp}`)
    }

    constructor (data) {
        super();Weave.prototype.__init.call(this);Weave.prototype.__init2.call(this);Weave.prototype.__init3.call(this);Weave.prototype.__init4.call(this); 

        if(data.name === undefined) {
            throw new Error("Undefined name for weave")
        }

        this.name = new Store(data.name);
        this.threads = new Tree(data.thread || {});
        this.rezed = new Store(new Set(data.rezed || []));

        this.threads_reverse = new Tree({}, set => {
            this.cancels.add(this.threads.listen(($threads) => {
                const w_r = {};
                for(let key of Object.keys($threads)) {
                    w_r[$threads[key]] = key;
                }

                set(w_r);
            }));
        });

        this.add(data.value || {});
    }

    add (warp_data, silent = false)  {
        if(!warp_data) return
        const warps = {};

        for(let [name, warp] of Object.entries(warp_data)) {
            if (warp instanceof Warp) {
                warps[name] = warp;
                continue
            }

            warp.name = name;
            warps[name] = this.create_warp(warp);
        }

        super.add(warps, silent);

        return warps
    }

    rez () {
        super.rez();

        // connect threads to form nerves
        this.thread_cancel = this.threads.listen(this.thread_update.bind(this));
    }

    thread_update ($threads) {
        for(let [name, cancel] of Object.entries(this.nerves)) {
            if($threads[name]) {
                delete $threads[name];
                continue
            }

            cancel();
            delete this.nerves[name];
        }

        for(let [from, to] of Object.entries($threads)) {
            const f = this.query(...from.split("/"));
            const t = this.query(...to.split("/"));
            if(!f || !t) continue
            this.nerves[from] = f.listen(t.set.bind(t));
        }
    }

    derez () {
        super.derez();
        
        for(let cancel of Object.values(this.nerves)) {
            cancel();
        }

        this.thread_cancel();
    }

    removes (...names) {
        const $warps = this.value.get();
        const $wefts = this.threads.get();
        const $wefts_r = this.threads_reverse.get();
        const $rezed = this.rezed.get();

        for(let name of names) {
            const warp = $warps[name];
            if(warp) warp.destroy();

            delete $warps[name];
            delete $wefts[name];
            $rezed.delete(name);

            const r = $wefts_r[name];
            if(r) {
                delete $wefts[r];
            }
        }

        this.value.set($warps);
        this.threads.set($wefts);
        this.rezed.set($rezed);
    }

    remove (name) {
        this.removes(name);
    }

    destroy() {
        super.destroy();

        for(let cancel of Array.from(this.cancels)) {
            cancel();
        }

        this.cancels.clear();
    }

    toJSON () {
        return {
            name: this.name.get(),
            thread: this.threads.get(),

            value: this.value.toJSON(),
            rezed: this.rezed.toJSON()
        }
    }
}

test("weave/", t => {
    const data = {
        name: "test",
        value: {
            foo: { type: EWarp.SPACE, value: {} },
            test: { type: EWarp.SPACE, value: {} }
        },
        thread: {
            foo: "test"
        },
        rezed: [
            "foo"
        ]
    };

    const weave = new Weave(data);

    t.deepEqual(data, weave.toJSON());

    weave.removes("foo", "test");
    
    t.snapshot(weave.toJSON());

    weave.add({
        foo: { value: {}},
        bar: { type: EWarp.SPACE, value: {}}
    });

    t.snapshot(weave.toJSON());

    weave.add({
        foo: { value: {} }
    });
    
    t.snapshot(weave.toJSON());

    weave.destroy();
    t.snapshot(weave.toJSON());
});

test("warp/", t => {
    const weave = new Weave({
        name: "test",
        value: {
            hello: {
                value: {VISIBLE: {
                    sprite: [5]
                }}
            }
        },
        thread: {},
        rezed: []
    });

    const { hello } = weave.value.get();
    t.snapshot(hello.toJSON());
    weave.destroy();
});

test("warp/space", t => {
    const weave = new Weave({
        name: "test",
        value: {
            hello: {
                value: {
                    VISIBLE: {
                        sprite: [5]
                    }
                }
            }
        },
        thread: {},
        rezed: []
    });

    const hello = weave.value.get().hello; 

    hello.add({ DATA: { foo: 5 } });
    t.snapshot(hello.toJSON());

    const vis = hello.item("VISIBLE");
    t.snapshot(vis.toJSON());
    vis.add({
        foo: new Store(5) 
    });

    t.snapshot(vis.get());
    vis.create();
    t.snapshot(vis.get());
    
    t.snapshot(weave.spaces.toJSON());
    weave.remove("hello");
    t.snapshot(weave.spaces.toJSON());
});

test("twist/visible", t => {
    Visible.data = new Buffer(Visible.defaults, 3);
    const weave = new Weave({
        name: "test",
        thread: {},
        rezed: [],
        value: {
            test: {
                value: {
                    VISIBLE: {
                        sprite: [2]
                    }
                }
            }
        }
    });

    t.snapshot(weave.toJSON());
    t.snapshot(Visible.data.toJSON());
});

test("twist/data", t => {
    const weave = new Weave({
        name: "test",
        thread: {},
        rezed: [],
        value: {
            test: {
                value: {
                    DATA: {
                        arbitrary: "hello"
                    }
                }   
            }
        }
    });

    t.snapshot(weave.toJSON());

    const space = weave.value.item("test"); 
    const data = space.item("DATA");
    
    t.snapshot(data.toJSON());

    data.add({
        foo: "5"
    });

    t.snapshot(data.toJSON());
});

test("twist/physical", t => {
    const weave = new Weave({
        name: "test",
        thread: {},
        rezed: [],
        value: {
            test: {
                value: {
                    PHYSICAL: {
                        position: [0,0,0]
                    }
                }
            }
        }
    });
 
    t.snapshot(weave.toJSON(), `should have defaults`);
});

let tick_set;
const tick = new Read(0, (set) => {
	tick_set = set;
});

let last_tick = Date.now();
const TIME_TICK_RATE = new Store(100);

const frame = new Read([0, 0], (set) => {
	let old;
	
	const data = [0, 0];
	const frame_t = (ts) => {
		raf_1(frame_t);

		if (old === undefined) old = ts;

		data[0] = ts;
		data[1] = Math.round(ts - old);

		old = ts;
		const now = Date.now();
		if (now - last_tick >= TIME_TICK_RATE.get()) {
			last_tick = now;
			tick_set(tick.get() + 1);
		}

		set(data);
	};

	raf_1(frame_t);
});

var time = /*#__PURE__*/Object.freeze({
	__proto__: null,
	tick: tick,
	TIME_TICK_RATE: TIME_TICK_RATE
});

// TODO: maybe an input one that gets written to from client?

test("sys/time", t => {
    t.snapshot(TIME_TICK_RATE.get());
});

class Wheel extends Living {
     __init() {this.value = new Tree({
        sys: new Weave({
            name: `sys`,
            thread: {},
            value: {},
            rezed: []
        })
    });}

    constructor (wheel_data) {
        super();Wheel.prototype.__init.call(this);
        
        this.rezed = new Store(new Set(wheel_data.rezed));
        
        this.add(wheel_data.value);
    }

    add (weaves, silent = false) {
        const write = {};

        for(let [name, value] of Object.entries(weaves)) {
            if(value instanceof Weave) {
                write[name] = value;
                continue
            }

            value.name = name;
            write[name] = new Weave(value);
        }

        super.add(write, silent);
    }
}

const simple = {
    rezed: ["test"],
    value: {
        test: {
            thread: {},
            rezed: ["test"],
            value: {
                test: {
                    type: EWarp.SPACE,
                    value: {
                        VISIBLE: {
                            sprite: [ 55 ]
                        }
                    }
                }
            }

        }
    }
};

test("wheel/", t => {
    const wheel = new Wheel(simple);

    t.snapshot(wheel.toJSON(), "loads");
    
    
});

class Messenger  {
    

    onmessage (event) {
        const msg = event.data;
        const fn = `msg_${msg.name}`;
        if(this[fn]) this[fn](msg.data);
    }

    postMessage (message) {
        this.remote.onmessage({ data: message });
    }
}

class RemoteGoblin extends Messenger {
    __init() {this.wheel = new Wheel({
        rezed: [],
        value: {}
    });}
    
    constructor (remote) {
        super();RemoteGoblin.prototype.__init.call(this);
        this.remote = remote;

        raf_1(() => {
            this.postMessage({
                name: "ready"
            });
        });
    }

     tick() {
        raf_1(() => {
            this.postMessage({
                name: "buffer",
                data: {
                    VISIBLE: Visible.data.toJSON()
                }
            });
        });
    }

     msg_toJSON () {
        this.postMessage({
            name: "toJSON",
            data: this.wheel.toJSON()
        });
    }

     msg_add (data) {
        this.wheel.add(data.value);

        for(let name of data.rezed) {
            this.wheel.start(name);
        }
    }

     msg_status (data) {
        this.wheel[data]();
        if(data !== ELivingAction.DESTROY) return

        this.postMessage({
            name: "destroy"
        });
    }

     msg_start (data) {
        this.wheel.start(data);
    }

     msg_stop (data) {
        this.wheel.stop(data);
    }

     msg_update (data


) {
        this.wheel.ensure(data.path[0], ...data.path.slice(1)).set(data.value);
    }

     msg_relay () {
        if(this.timeout) this.timeout();
        this.timeout = this.wheel.query("sys", "time", "tick").listen(this.tick.bind(this));
    }
}

class LocalWorker extends Messenger  {constructor(...args) { super(...args); LocalWorker.prototype.__init.call(this); }
     __init() {this.remote = new RemoteGoblin(this);}

    terminate() {
        // okay
    }

    onerror (ev) {
        // okay
    }
}  

class Goblin extends Living {
    // this could use sharedmemory but not everyone supports it
    __init2() {this.buffer = new Tree({
        VISIBLE: Visible.data
    });}

    
     __init3() {this.value = this.buffer;}
    
     __init4() {this.sys_cancels = {};}
    
    

     __init5() {this.json_resolvers = [];}

    constructor (sys, local = false) {
        super();Goblin.prototype.__init2.call(this);Goblin.prototype.__init3.call(this);Goblin.prototype.__init4.call(this);Goblin.prototype.__init5.call(this);Goblin.prototype.__init6.call(this);

        this.sys = sys;
        this.local = local;
    }

    create () {
        super.create();

        this.worker = this.local ? new LocalWorker() : new Worker(`/bin/wheel.bundle.js`);

        this.worker.onmessage = this.onmessage.bind(this);
        this.worker.onerror = this.onerror.bind(this);

        this.worker.postMessage({
            name: "status",
            data: ELivingAction.CREATE
        });
    }

    rez () {
        super.rez();

        this.sys_cancel = this.sys.listen(this.sys_update.bind(this));

        this.worker.postMessage({
            name: "status",
            data: ELivingAction.REZ
        });
    }

    derez () {
        super.derez();

        for(let cancel of Object.values(this.sys_cancels)) {
            cancel();
        }

        this.sys_cancel();

        this.worker.postMessage({
            name: "status",
            data: ELivingAction.DEREZ
        });
    }

    destroy () {
        super.destroy();

        this.worker.postMessage({
            name: "status",
            data: ELivingAction.DESTROY
        });
    }

    // replicate system changes into the worker
     sys_update ($sys) {
        // this should happen very rarely
        for(let cancel of Object.values(this.sys_cancels)) {
            cancel();
        }
        
        this.sys_cancels = {};

        for(let [name, category] of Object.entries($sys)) {
            this.sys_cancels[name] = category.listen(($category) => {
                for(let [key, store] of Object.entries($category)) {
                    this.sys_cancels[`${name}/${key}`] = store.listen($store => {
                        this.worker.postMessage({
                            name: "update",
                            data: {
                                path: [`sys`, name, key],
                                value: $store
                            }
                        });
                    });
                }
            });
        }
    }

     msg_destroy () {
        this.worker.terminate();
    }

     msg_toJSON (json) {
        for(let resolve of this.json_resolvers) {
            resolve(json);
        }
    }

     msg_buffer (data) {
        for(let [name, buffer] of Object.entries(data)) {
            const buff = this.buffer.item(name);

            if(buff === undefined) return
            buff.hydrate(buffer);
        }

        this.notify();
    }

     msg_ready () {
        this.worker.postMessage({
            name: "relay"
        });
    }

     __init6() {this.onmessage = Messenger.prototype.onmessage;}

     onerror (event) {
        console.error(`Worker Error`, event);
    }

    async remote_toJSON () {
        return new Promise((resolve) => {
            this.json_resolvers.push(resolve);

            if(this.json_resolvers.length !== 1) return

            this.worker.postMessage({
                name: "toJSON"
            });
        })
    }

    remote_add (data) {
        this.worker.postMessage({
            name: "add",
            data
        });
    }

    remote_start (data) {
        this.worker.postMessage({
            name: "start",
            data
        });
    }

    remote_stop (data) {
        this.worker.postMessage({
            name: "stop",
            data
        });
    }
}

TIME_TICK_RATE.set(10);

test("goblin/", async t => {
    const worker = new Goblin(new Tree({
        test: new Tree({
            1: new Store(5)
        }),
        time: new Tree(time)
    }), true);

    worker.create();
    worker.rez();

    t.snapshot(worker);
    t.snapshot(worker.toJSON());

    worker.remote_add(simple);

    t.snapshot(await worker.remote_toJSON());

    let count = 0;

    await new Promise(resolve => {
        const cancel = worker.listen($buffer => {
            t.snapshot($buffer.VISIBLE.toJSON());

            if(count++ < 4) return
            cancel();
            resolve();
        });
    });
});

// Starts up in the main thread
class Isekai extends Living {
     __init() {this.wheels = new Tree();}
     __init2() {this.value = this.wheels;}
    
     __init3() {this.sys = new Tree();}
     __init4() {this.local = new Store(false);}

    constructor(sys, local = false) {
        super();Isekai.prototype.__init.call(this);Isekai.prototype.__init2.call(this);Isekai.prototype.__init3.call(this);Isekai.prototype.__init4.call(this);
        this.local.set(local);

        const write = {};
        for(let [name, value] of Object.entries(sys)) {
            write[name] = new Tree(value);
        }

        this.sys.add(write);

        // Check Path
        // Check Database
        this.create();
        this.rez();
    }

    add (wheels) {
        const write = {};

        for(let [name, wheel_json] of Object.entries(wheels)) {
            const worker = write[name] = new Goblin(this.sys, this.local.get());
            worker.add(wheel_json);
        }

        super.add(write);
    }
}

test("isekai/", t => {
    const isekai = new Isekai({
        test: {
            there: new Store(1)
        },
        time
    }, true);

    t.snapshot(isekai.toJSON(), "base snapshot");
    t.snapshot(isekai.sys.query("test", "there").get());

    isekai.add({ simple });

    t.snapshot(isekai);
});
//# sourceMappingURL=bundle.test.js.map

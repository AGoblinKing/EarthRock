'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var test = _interopDefault(require('ava'));
var cuid = _interopDefault(require('cuid'));

// Stores are observables
class Store  {
	
	

	constructor(value) {
		this.value = value;
	}

	notify () {
		if (!this.listeners) return
		this.listeners.forEach((listener) => listener(this.value));
	}

	subscribe(listener) {
		return this.listen(listener)
	}

	listen (listener, no_initial = false)  { 
		if (!this.listeners) this.listeners = new Set();

		this.listeners.add(listener);
		
		if (!no_initial) listener(this.get());

		return () => this.listeners.delete(listener)
	}

	get ()  { return this.value }
	
	set (value, silent = false) {
		this.value = value;
		if(silent) return
		
		this.notify();
	}

	update (updator) {
		this.set(updator(this.value));
	}

	toJSON ()  {
		switch (typeof this.value) {
		case `undefined`:
		case `number`:
		case `string`:
			return this.value 

		case `object`:
			if(Set.prototype.isPrototypeOf(this.value)) {
				return Array.from(this.value)
			}

			if (
				Array.isArray(this.value) ||
				this.value === null
			) {
				return this.value
			}
			
			if (this.value.toJSON) {
				return this.value.toJSON()
			}
		}

		return JSON.parse(
			JSON.stringify(this.value)
		)
	}
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);

//# sourceMappingURL=performance-now.js.map
});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

test("store/store", t => {
    const s = new Store(5);
    t.snapshot(s.get());

    s.set(6);
    t.snapshot(s.get());

    s.update((i) => i + 1);
    t.snapshot(s.get());
});

test("store/observable", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.subscribe(($value) => {
            t.snapshot($value);

            raf_1(() => {
                cancel();
                s.set(7);
                resolve();
            });
        });
    });
});

test("store/listen/silent", async t => {
    const s = new Store(6);

    await new Promise((resolve) => {
        t.plan(1);

        const cancel = s.listen(($value) => {
            t.snapshot($value);
            cancel();
            resolve();
        }, true);

        s.set(7);
    });
});

test("store/toJSON", t => {
    t.snapshot(new Store({"foo": "bar"}).toJSON());
    t.snapshot(new Store(5).toJSON());
    t.snapshot(new Store([5, 5]).toJSON());
    t.snapshot(new Store(new Store(5)).toJSON());
});

test("store/set/silent", t => {
    t.plan(1);
    const store = new Store(5);
    store.listen(($value) => {
        t.pass();
    }, true);

    store.set(6, true);
    store.set(7);
});

class Read extends Store {
    constructor(value, setter) {
        super(value);

        if(setter) setter(Store.prototype.set.bind(this));
    }

     p_set(value, silent = false) {
        super.set(value, silent);
    }

    set(value, silent = false) {
        return
    }
}

class Tree extends Read {
	

	constructor(tree = {}, setter) {
		super(tree, setter);
	}

	item (name) {
		return super.get()[name]
	}

	reset (target, silent = false) {
		const $tree = {};
		if(target) {
			Object.assign($tree, target);
		}

		this.p_set($tree, silent);
	}

	write (tree_json, silent = false) {
		const $tree = this.get();
		Object.assign($tree, tree_json);

		this.p_set($tree, silent);
	}

	remove (name, silent = false) {
		delete this.value[name];
		if(!silent) this.notify();
	}
	
	query (...steps)  {
		
		const cursor = this.value[steps.shift()]; 

		if(steps.length === 0 || !cursor) return cursor 	
		return cursor.query(...steps)
    }
}

test("store/tree", t => {
    const tree = new Tree({
        foo: 1,
        bar: "2",
        store: new Store(5),
        stores: new Store(new Store("string"))
    });

    t.snapshot(tree.get());
});

test("store/tree/names", t => {
    const tree = new Tree({
        foo: 1,
        bar: "2",
        store: new Store(5),
        stores: new Store(new Store("string"))
    });

    tree.write({foo: 2});
    t.snapshot(tree.get());
    t.snapshot(tree.item("foo"));


    tree.write({
        foo: 5,
        store: 1,
        new_thing: "new"
    });

    t.snapshot(tree.get());
    t.snapshot(tree.toJSON());


    tree.remove("store");

    t.snapshot(tree.get());
});



test("store/tree/query", t => {
    const tree = new Tree({
        foo: 1,
        nest: new Tree({
            deeper: new Tree({
                final: 3
            }),
            mid: 2
        })
    });

    t.snapshot(tree.query("foo"));
    t.snapshot(tree.query("nest"));
    t.snapshot(tree.query("nest", "mid"));
    t.snapshot(tree.query("nest", "deeper"));
    t.snapshot(tree.query("nest", "deeper", "final"));
});

test("store/read", t => {
    t.plan(3);
    let setter;
    const read = new Read(5, set => {
        setter = set;
    });

    const cancel = read.listen(($value) => {
        t.true($value === 10);
        cancel();
    }, true);

    t.snapshot(read.get());
    read.set(6);
    t.snapshot(read.get());

    setter(10);
});

class Proxy {
    

    get() { return this.value.get() }
    listen(listen) { return this.value.listen(listen) }
    set(value, silent = false) { this.value.set(value, silent); }
    toJSON() { return this.value.toJSON() }
    notify() { this.value.notify(); }
}

class ProxyTree extends Proxy {
    
    
    item (name) {
        return this.value.item(name)
    }

    reset (target, silent)  {
        return this.value.reset(target, silent)
    }

    write (tree_write, silent) {
        return this.value.write(tree_write, silent)
    }

    remove (name, silent) {
        this.value.remove(name, silent);
    }

    query (...steps)  {
        return this.value.query(...steps)
    }
}

class Buffer extends Tree {
    
    
    
    

     create_data(size) {
        const data = {};
        
        for(let key of Object.keys(this.defaults)) {
            data[key] = new Float32Array(this.defaults[key].length * size);

            // copy existing data
            if(this.data) {
                data[key].set(this.data[key]);
            }
        }
        
        if(this.available) {
            const additions = Array.from(Array(size - this.count).keys()).map(i => i + this.count);
            this.available = new Set([...Array.from(this.available), ...additions]);
        } else {
            this.available = new Set(Array(size).keys());
        }

        this.data = data;
        this.count = size;
    }

    constructor(defaults, initial_size = 100) {
        super();

        this.defaults = defaults;
        this.create_data(initial_size);
    }
    
    allocates(...data)  {
        const results = [];
        for(let datum of data) {
            results.push(this.allocate(datum));
        }

        return results
    }

    allocate(datum)  {
        const buffer_view = {};
        let cursor = this.available.values().next().value;
        if(cursor === undefined) {
            this.resize();
            cursor = this.available.values().next().value;
        }

        this.available.delete(cursor);

        for(let key of Object.keys(this.defaults)) {
            const len = this.defaults[key].length;
            const idx = cursor * len; 
            const view = this.data[key].subarray(idx, idx + len);

            view.set(datum[key] ? datum[key] : this.defaults[key]);

            buffer_view[key] = new Store(view);
        }

        return [buffer_view, cursor]
    }

    free(idx) {
        this.available.add(idx);

        for(let key of Object.keys(this.defaults)) {    
            const len = this.defaults[key].length;
            this.data[key].set(Array(len).fill(0), len * idx);
        }
    }

    resize(size) {
        if(size === undefined) size = this.count * 2;
        if(size < this.count) throw new Error("cannot reduce the size of a buffer")

        this.create_data(size);
        this.notify();
    }

    toJSON()  {
        const json = {};
        for(let key of Object.keys(this.data)) {
            json[key] = Array.from(this.data[key]);
        }

        return json
    }
}

test("store/buffer", t => {
    const buffer = new Buffer({
        test: [1, 2],
        2: [3, 4]
    }, 3);

    t.snapshot(buffer.toJSON());

    const [item, idx] = buffer.allocate({test: [0, 1]});
    
    t.snapshot(buffer.toJSON());
    t.snapshot(item.test.get());

    const test = item.test.get();
    test[0] = 5;
    item.test.notify();

    t.snapshot(buffer.toJSON());

    buffer.free(0);
    t.snapshot(buffer.toJSON());

    buffer.allocate({test: [1, 2]});
    buffer.allocates({test: [3, 4]}, {test: [5, 6]}, {test: [7, 9]});

    t.snapshot(buffer.toJSON(), "allocates works, and resizes");

    buffer.resize();
    t.snapshot(buffer.toJSON(), "resizeable");
});

const TILE_COUNT = 1024;

const str_color = (str) => {
	if (!str) return `#111`

	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	let color = `#`;
	for (let i = 0; i < 3; i++) {
		const value = (hash >> (i * 8)) & 0xFF;
		color += (`00` + value.toString(16)).substr(-2);
	}
	
	return color
};

const color = str_color;

// whiskers on kittens
const words = [
	`groovy`, `cat`, `bird`, `dog`, `poop`, `cool`, `not`, `okay`, `great`, `terrible`, `wat`,
	`goblin`, `life`, `ferret`, `gregert`, `robert`, `zilla`, `red`, `shirt`, `pants`, `blue`,
	`luna`, `ember`, `embear`, `lunatic`, `boring`, `killa`, `notice`, `thank`, `tank`,
	`under`, `near`, `near`, `quaint`, `potato`, `egg`, `bacon`, `narwhal`, `lamp`, `stairs`, `king`,
	`tyrant`, `grave`, `dire`, `happy`, `amazing`, `terrific`, `terrible`, `good`, `boring`,
	`rip`, `hello`, `world`, `global`, `universal`, `television`, `computer`
];

const tile = (str) => {
	let hash = 0;
	for (let i = 0; i < str.length; i++) {
		hash = str.charCodeAt(i) + ((hash << 5) - hash);
	}

	return `${Math.abs(hash) % TILE_COUNT}`
};

const random = (count) => Array
	.from(new Array(count))
	.map(() => words[Math.floor(Math.random() * words.length)])
	.join(`_`);

test("lib/text", t => {
    t.snapshot(tile("hello"));
    t.is(typeof random(2), "string");
});

var EWarp; (function (EWarp) {
    const SPACE = "SPACE"; EWarp["SPACE"] = SPACE;
    const MATH = "MATH"; EWarp["MATH"] = MATH;
    const VALUE = "VALUE"; EWarp["VALUE"] = VALUE;
    const MAIL = "MAIL"; EWarp["MAIL"] = MAIL;
})(EWarp || (EWarp = {}));

class Warp extends Proxy {
    
    

    
    

    constructor(data, weave) {
        super();

        this.name = data.name;
        this.type = data.type;
        this.weave = weave;

        // don't init value because who knows what they want
    }

    destroy () { /* no-op */ }
    create() { /* no-op */ }
    rez () { /* no-op */ }
    derez () { /* no-op */ }

    toJSON() {
        return {
            name: this.name,
            type: this.type,
            value: this.value.toJSON()
        }
    }
}

var ETwist; (function (ETwist) {
    const VISIBLE = "VISIBLE"; ETwist["VISIBLE"] = VISIBLE;
    const PHYSICAL = "PHYSICAL"; ETwist["PHYSICAL"] = PHYSICAL;
    const DATA = "DATA"; ETwist["DATA"] = DATA;
})(ETwist || (ETwist = {}));





class Twist extends ProxyTree {
    
    
    

    static map_to_stores (twist_data) {
        const stores = {};

        for(let key of Object.keys(twist_data)) {
            stores[key] = new Store(twist_data[key]);
        }

        return stores
    }

    constructor (weave, space) {
        super();

        this.space = space;
        this.weave = weave;
        this.value = new Tree({});
    }
}

// Visible spaces
class Visible extends Twist { 
    static __initStatic() {this.defaults = { 
        position: [0, 0, 0],
        sprite: [0],
        scale: [1],
        color: [255, 255, 255, 1],
        rotation: [0]
    };}

    static __initStatic2() {this.data = new Buffer(Visible.defaults);}

    

    constructor(weave, space, visible_data) {
        // set the views
        super(weave, space);
        const [view, idx] = Visible.data.allocate(visible_data);
        this.index = idx;
        this.write(view);
    }

    toJSON() {
        const json = {};
        const $value = this.get();
        for(let key of Object.keys($value)) {
            const $item = $value[key].get();

            json[key] = Array.from($item);
        }

        return json
    }
} Visible.__initStatic(); Visible.__initStatic2();

class Data extends Twist  {
    constructor(weave,  space, data) {
        super(weave, space);
        this.write(Twist.map_to_stores(data));
    }
}

class Physical extends Twist {
    constructor(weave,  space, physical_data = {}) {
        super(weave, space);
        this.write(Twist.map_to_stores(physical_data));
    }
}

class Space extends Warp {
    

    constructor(warp_data, weave) {
        super(warp_data, weave);

        const data = warp_data.value;

        const twists = {};
        for(let type of Object.keys(data)) {
            twists[type] = this.add_twist(type, weave, data[type]);
        }

        this.value = new Tree(twists);
    }

    item (name) {
        return this.value.item(name)
    }

    reset (target, silent)  {
        return this.value.reset(target, silent)
    }

    write (tree_write, silent) {
        return this.value.write(tree_write, silent)
    }

    remove (name, silent) {
        this.value.remove(name, silent);
    }

    query (...steps)  {
        return this.value.query(...steps)
    }

    add_twist (type, weave, twist_data = {}) {
        switch(type) {
            case ETwist.DATA:
                return new Data(weave, this, twist_data)
            case ETwist.VISIBLE: 
                return new Visible(weave, this, twist_data )
            case ETwist.PHYSICAL:
                return new Physical(weave, this, twist_data )
        }

        throw new Error(`unknown twist ${type}`)
    }

    create() {
        this.weave.spaces.write({ [this.name]: this });
    }

    destroy() {
        this.weave.spaces.remove(this.name);
    }

}

// export * from "./mail"
// export * from "./value"

class Weave extends ProxyTree{
    
    
    
    

    // caches
    
    

    // clean up
    

    create_warp($warp) {
        switch($warp.type) {
            case undefined:
                $warp.type = EWarp.SPACE;
            case EWarp.SPACE:
                return new Space($warp, this)
            case EWarp.MAIL:
            case EWarp.VALUE:
            case EWarp.MATH:
        }

        throw new Error(`warp/unknown ${$warp}`)
    }

    constructor(data) {
        super();

        this.name = new Store(data.name);
        this.wefts = new Tree(data.wefts);
        this.value = this.warps = new Tree({});
        this.rezed = new Store(new Set(data.rezed));
        
        this.cancels = new Set();

        this.wefts_reverse = new Tree({}, set => {
            this.cancels.add(this.wefts.listen(($wefts) => {
                const w_r = {};
                for(let key of Object.keys($wefts)) {
                    w_r[$wefts[key]] = key;   
                }

                set(w_r);
            }));
        });

        this.write(data.warps);
    }

    write(warp_data, silent = false)  {
        const warps = {};

        for(let id of Object.keys(warp_data)) {
            const warp = warp_data[id];  
            warp.name = warp.name === "cuid" ? cuid() : id;

            warps[id] = this.create_warp(warp);
        }

        this.warps.set(Object.assign(this.warps.get(), warps), silent);
        return warps
    }

    delete(...ids) {
        const $warps = this.warps.get();
        const $wefts = this.wefts.get();
        const $wefts_r = this.wefts_reverse.get();
        const $rezed = this.rezed.get();

        for(let id of ids) {
            delete $warps[id];
            delete $wefts[id];
            $rezed.delete(id);

            const r = $wefts_r[id];
            if(r) {
                delete $wefts[r];
            }
        }
        // TODO: Notify destruction if rezed

        this.warps.set($warps);
        this.wefts.set($wefts);
        this.rezed.set($rezed);
    }

    destroy() {
        this.delete(...Object.keys(this.warps.get()));
        for(let cancel of Array.from(this.cancels)) {
            cancel();
        }
        this.cancels.clear();
    }

    toJSON()  {
        return {
            name: this.name.get(),
            wefts: this.wefts.get(),
            warps: this.warps.toJSON(),
            rezed: this.rezed.toJSON()
        }
    }
}

test("weave/", t => {
    const data = {
        name: "test",
        warps: {
            foo: { type: EWarp.SPACE, value: {} },
            test: { type: EWarp.SPACE, value: {} }
        },
        wefts: {
            foo: "test"
        },
        rezed: [
            "foo"
        ]
    };

    const weave = new Weave(data);

    t.deepEqual(data, weave.toJSON());

    weave.delete("foo", "test");
    
    t.snapshot(weave.toJSON());

    weave.write({
        foo: { value: {}},
        bar: { type: EWarp.SPACE, value: {}}
    });

    t.snapshot(weave.toJSON());

    weave.write({
        foo: { value: {} }
    });
    
    t.snapshot(weave.toJSON());

    weave.destroy();
    t.snapshot(weave.toJSON());
});

test("warp/", t => {
    const weave = new Weave({
        name: "test",
        warps: {
            hello: {
                value: {VISIBLE: {
                    sprite: [5]
                }}
            }
        },
        wefts: {},
        rezed: []
    } );

    const { hello } = weave.warps.get();
    t.snapshot(hello.toJSON());
    weave.destroy();
});

test("warp/space", t => {
    const weave = new Weave({
        name: "test",
        warps: {
            hello: {
                value: {VISIBLE: {
                    sprite: [5]
                }}
            }
        },
        wefts: {},
        rezed: []
    } );

    const hello = weave.warps.get().hello; 

    hello.write({ DATA: { foo: 5 } });
    t.snapshot(hello.toJSON());

    const vis = hello.item("VISIBLE");
    t.snapshot(vis.toJSON());
    vis.write({
        foo: new Store(5) 
    });

    t.snapshot(vis.get());
});

test("twist/visible", t => {
    Visible.data = new Buffer(Visible.defaults, 3);
    const weave = new Weave({
        name: "test",
        wefts: {},
        rezed: [],
        warps: {
            test: {
                value: {
                    VISIBLE: {
                        sprite: [2]
                    }
                }
            }
        }
    });

    t.snapshot(weave.toJSON());
    t.snapshot(Visible.data.toJSON());
});

test("twist/data", t => {
    const weave = new Weave({
        name: "test",
        wefts: {},
        rezed: [],
        warps: {
            test: {
                value: {
                    DATA: {
                        arbitrary: "hello"
                    }
                }   
            }
        }
    });

    t.snapshot(weave.toJSON());

    const space = weave.warps.item("test"); 
    const data = space.item("DATA");
    
    t.snapshot(data.toJSON());

    data.write({
        foo: "5"
    });

    t.snapshot(data.toJSON());
});

test("twist/physical", t => {
    const weave = new Weave({
        name: "test",
        wefts: {},
        rezed: [],
        warps: {
            test: {
                value: {
                    PHYSICAL: {
                        position: [0,0,0]
                    }
                }
            }
        }
    });
 
    t.snapshot(weave.toJSON(), `should have defaults`);
});

let tick_set;
const tick = new Read(0, (set) => {
	tick_set = set;
});

let last_tick = Date.now();
const TIME_TICK_RATE = new Store(100);

const frame = new Read([0, 0], (set) => {
	let old;
	
	const data = [0, 0];
	const frame_t = (ts) => {
		raf_1(frame_t);

		if (old === undefined) old = ts;

		data[0] = ts;
		data[1] = Math.round(ts - old);

		old = ts;
		const now = Date.now();
		if (now - last_tick >= TIME_TICK_RATE.get()) {
			last_tick = now;
			tick_set(tick.get() + 1);
		}

		set(data);
	};

	raf_1(frame_t);
});

var time = /*#__PURE__*/Object.freeze({
	__proto__: null,
	tick: tick,
	TIME_TICK_RATE: TIME_TICK_RATE,
	frame: frame
});

// TODO: maybe an input one that gets written to from client?

var sys = /*#__PURE__*/Object.freeze({
	__proto__: null,
	TIME: time
});

test("sys/time", t => {
    t.snapshot(sys);

    raf_1(() => {
        t.snapshot(tick);
    });

    return new Promise(resolve => setTimeout(() => {
        t.snapshot(tick);
        resolve();
    }, 101))
});
//# sourceMappingURL=bundle.test.js.map
